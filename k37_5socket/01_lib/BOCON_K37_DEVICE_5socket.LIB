/*** BeginHeader */
#ifndef _BOCON_K37_DEVICE_LIB
#define _BOCON_K37_DEVICE_LIB
/*** EndHeader */
/**************************************************************************
    广 州 博 控 自 动 化 技 术 有 限 公 司
      K37串口仪表设备驱动库
    2010-02-02
统一使用设备驱动的缓冲区：com_f[21], com_sec是时间
最多从一个设备读取21个参数，参数位置需要预定义好
Baudrate:   1200,4800,9600,19200,38400,57600,115200
Parity:     0  -- PARAM_NOPARITY
    1  -- PARAM_EPARITY
    2  -- PARAM_OPARITY
    3  -- PARAM_2STOP
Databits    0  -- PARAM_8BIT
    1  -- PARAM_7BIT

返回非0 表示操作结束,
返回1   表示数据正常,
返回2   表示设备不正常,
**************************************************************************/

/*** BeginHeader */
#use "bocon_mb_crc.elib"
#use "bocon_k37_deviceProtocolEnableMacroDefine.lib"
#use "ModbusDevice.lib"

#define AINBUFSIZE   511
#define AOUTBUFSIZE  255//63
#define BINBUFSIZE   511
#define BOUTBUFSIZE  127//63
#define DINBUFSIZE   63
#define DOUTBUFSIZE  63

#define EINBUFSIZE   255
#define EOUTBUFSIZE  127
#define FINBUFSIZE   511//255
#define FOUTBUFSIZE  1023//63

union uf {
    float f;
    char ch[4];
    unsigned int i[2];
    int signed[2];
    unsigned long l;
};

typedef union
{
    unsigned int i;
    char c[2];
}CHARTOINTTY;

float com_f[21];        //每个串口最多可读取21个参数，不包括时间值
unsigned long com_sec;  //读到的时间

char comOpenSign[8];     //用于控制串口打开与关闭的,好像如果仪器是自动发送数据上来的,串口只需要打开一次而已,不需要关闭
float flux;
float fluxSum;

/*** EndHeader */

/*** BeginHeader initDevice*/
void initDevice(void);
/*** EndHeader */
void initDevice(void)
{
    memset(comOpenSign, 0x00, sizeof(comOpenSign));
    //memset(deviceStatus,0x00,sizeof(deviceStatus));
    //memset(dev_state,0x00,sizeof(dev_state));
}

/*** BeginHeader com_rdFlush*/
void com_rdFlush(char port);
/*** EndHeader */
void com_rdFlush(char port)
{
    switch (port)
    {
    case 0:
        serFrdFlush();
        break;
    case 1:
        serArdFlush();
        break;
    case 2:
    case 3:
    case 4:
    case 5:
        serErdFlush();
        break;
    case 6:
        serBrdFlush();
        break;
    default:
        ;
    }
}

/*** BeginHeader com_wrFlush*/
void com_wrFlush(char port);
/*** EndHeader */
void com_wrFlush(char port)
{
    switch (port)
    {
    case 0:
        serFwrFlush();
        break;
    case 1:
        serAwrFlush();
        break;
    case 2:
    case 3:
    case 4:
    case 5:
        serEwrFlush();
        break;
    case 6:
        serBwrFlush();
        break;
    default:
        ;
    }
}

/*** BeginHeader com_readV2*/
int com_readV2(char port, void *data, int length, unsigned long tmout);
/*** EndHeader */
int com_readV2(char port, void *data, int length, unsigned long tmout)
{
    int len;

    switch (port)
    {
    case 0:
        len = serFread(data, length, tmout);
        break;
    case 1:
        len = serAread(data, length, tmout);
        break;
    case 2:
    case 3:
    case 4:
    case 5:
        len = serEread(data, length, tmout);
        break;
    case 6:
        len = serBread(data, length, tmout);
        break;
    default:
        len = 0;
        break;
    }

    return len;
}

/*** BeginHeader searchCodeTable */
void searchCodeTable(void);
/*** EndHeader */
void searchCodeTable(void)
{
    auto int i;
    auto char p;

    memset(codeTable, 0x00, sizeof(codeTable));
    codeCount = 0;

    for (i = 0; i < ALLADCHANNELS; i++)
    {
        if ((Savech[i].polIndex >= 0) && (Savech[i].polIndex < BOCON_NO_OF_POL / 2))
        {
            p = Savech[i].polIndex;
            if (Savech[i].zs_index < ALLADCHANNELS)    //本通道有折算值
            {
                codeTable[codeCount].polIndex = Savech[i].polIndex;
                codeTable[codeCount].zs_index = Savech[i].zs_index;
                strcpy(codeTable[codeCount].code, PolCode[p]);
            }
            else
            {
                codeTable[codeCount].polIndex = Savech[i].polIndex;
                strcpy(codeTable[codeCount].code, PolCode[p]);
            }
#ifdef DEBUG_PRINTF
            printf("code=%s, polIndex=%d, zs_index=%d \n",
                   codeTable[codeCount].code, codeTable[codeCount].polIndex, codeTable[codeCount].zs_index);
#endif
            codeCount++;
        }
    }
}
/*** BeginHeader open_port*/
void open_port(char port);
/*** EndHeader */
void open_port(char port)
{
    com_open(port, ai_param[port + 8].baudrate); //用指定的波特率打开串口
    com_databits(port, PARAM_8BIT);           //8个数据位，PARAM_7BIT
    com_parity(port, ai_param[port + 8].parity); //校验位，0,1,2,3
    com_rdFlush(port);
    com_wrFlush(port);
    msDelay(20);
}

/*** BeginHeader setRegFloatValue*/
char setRegFloatValue(char port, float f, char offset);
/*** EndHeader */
char setRegFloatValue(char port, float f, char offset)
{
    auto char k;
    auto union uf data;

    if (port >= 8) return 0;
    if (offset >= sizeof(com_tbuf)) return 0;
    k = offset;

    data.f = f;

    switch (modbusConfig[port].dataSort)
    {
    case DT_FLOAT_INVERSE:
        com_tbuf[k++] = data.ch[3];
        com_tbuf[k++] = data.ch[2];
        com_tbuf[k++] = data.ch[1];
        com_tbuf[k++] = data.ch[0];
        break;
    case DT_FLOAT_0123:
        com_tbuf[k++] = data.ch[0];
        com_tbuf[k++] = data.ch[1];
        com_tbuf[k++] = data.ch[2];
        com_tbuf[k++] = data.ch[3];
        break;
    case DT_FLOAT_2301:
        com_tbuf[k++] = data.ch[2];
        com_tbuf[k++] = data.ch[3];
        com_tbuf[k++] = data.ch[0];
        com_tbuf[k++] = data.ch[1];
        break;
    default:
        com_tbuf[k++] = data.ch[1];
        com_tbuf[k++] = data.ch[0];
        com_tbuf[k++] = data.ch[3];
        com_tbuf[k++] = data.ch[2];
        break;
    }

    return k;
}

//Tx:00 00 00 00 00 06 01 03 00 00 00 0A
//Rx:00 00 00 00 00 17 01 03 14 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
/*** BeginHeader tcp_modbus_slave_task*/
void tcp_modbus_slave_task(char port);
/*** EndHeader */
void tcp_modbus_slave_task(char port)
{
    auto unsigned int crc;
    auto char crc1, crc2;
    auto CHARTOINTTY regAddr; //读寄存器开始地址
    auto CHARTOINTTY regCount; //读寄存器数量
    auto unsigned int stratAddr;
    auto unsigned int count;
    auto char p, i, k;
    auto union uf data;
    auto char fluxPos;     //瞬时流量的位置
    auto char fluxFlag;   //1-查询到瞬时流量在什么位置
    auto char codeCount;  //统计一共有多少个污染物
    auto float totalFlux;
    costate
    {
        com_open(port, ai_param[port + 8].baudrate); //用指定的波特率打开串口
        com_databits(port, PARAM_8BIT);           //8个数据位，PARAM_7BIT
        com_parity(port, ai_param[port + 8].parity); //校验位，0,1,2,3
        msDelay(20);
        while (1)
        {
            com_read(port);
            if ((com_rlen >= 12) && (com_rbuf[6] == modbusConfig[port].devAddr) && (com_rbuf[7] == 0x03 || com_rbuf[7] == 0x04))
            {
                regAddr.c[1] = com_rbuf[8];
                regAddr.c[0] = com_rbuf[9];

                regCount.c[1] = com_rbuf[10];
                regCount.c[0] = com_rbuf[11];

                com_tbuf[0] = com_rbuf[0];
                com_tbuf[1] = com_rbuf[1];
                com_tbuf[2] = com_rbuf[2];
                com_tbuf[3] = com_rbuf[3];
                com_tbuf[4] = com_rbuf[4];

                com_tbuf[5] = regCount.i * 2 + 3; //长度
                com_tbuf[6] = modbusConfig[port].devAddr;
                com_tbuf[7] = com_rbuf[7];
                com_tbuf[8] = 0x00;
                count = 499;   //开始地址是500
                totalFlux = 0.0;
                for (i = 0; i < ALLADCHANNELS; i++)
                {
                    if (Savech[i].polIndex == 81)
                    {
                        totalFlux = Savech[i].val;
                        break;
                    }
                }
                for (i = 0, k = 9; i < ALLADCHANNELS; i++)
                {
                    if ((Savech[i].polIndex >= 0) && (Savech[i].polIndex < BOCON_NO_OF_POL / 2))
                    {
                        count += 2;
                        if (com_tbuf[8] >= regCount.i * 2) break;
                        if (count >= regAddr.i)
                        {
                            if (Savech[i].zs_index < ALLADCHANNELS)    //本通道有折算值
                            {
                                k = setRegFloatValue(port, Savech[i].val, k);
                                k = setRegFloatValue(port, Savech[Savech[i].zs_index].val, k);
                                com_tbuf[8] += 8;
                            }
                            else
                            {
                                if (Savech[i].polIndex == 0)
                                {
                                    k = setRegFloatValue(port, Savech[i].val, k);
                                    k = setRegFloatValue(port, onemsg_wr.AI_Val[i].Total, k);
                                    com_tbuf[8] += 8;
                                }
                                else
                                {
                                    k = setRegFloatValue(port, Savech[i].val, k);
                                    com_tbuf[8] += 4;
                                }
                            }
                        }
                    }
                }
                com_tlen = k;          //发送数据长度
                com_write(port);
            }
            waitfor(DelayMs(1000));
        }
    }
}

//000000-Tx:00 02 00 00 00 06 01 03 00 00 00 0A
//000001-Rx:00 02 00 00 00 17 01 03 14 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
/*** BeginHeader modbus_tcp_tasks*/
void modbus_tcp_tasks(char no);
/*** EndHeader */
void modbus_tcp_tasks(char no)
{
    auto char TcpBuf[500];
    auto CHARTOINTTY regAddr; //读寄存器开始地址
    auto CHARTOINTTY regCount; //读寄存器数量
    auto char  i;
    auto int  index;
    auto char  cnt;
    auto union uf data;

    xmem2root(deal_buf, tcp_rbuf[no], tcp_rlen[no]);

    memset(TcpBuf, 0x00, sizeof(TcpBuf));
    if (tcp_rlen[no] >= 11 && deal_buf[6] == devNo && (deal_buf[7] == 0x03 || deal_buf[7] == 0x04))
    {
        regAddr.c[1] = deal_buf[8];
        regAddr.c[0] = deal_buf[9];

        regCount.c[1] = deal_buf[10];
        regCount.c[0] = deal_buf[11];

        index = 0;
        TcpBuf[0] = deal_buf[0];
        TcpBuf[1] = deal_buf[1];
        TcpBuf[2] = deal_buf[2];
        TcpBuf[3] = deal_buf[3];
        TcpBuf[4] = deal_buf[4];
        TcpBuf[5] = regCount.i * 2 + 3;
        TcpBuf[6] = devNo;
        TcpBuf[7] = deal_buf[7];
        TcpBuf[8] = regCount.i * 2; //长度
        index = 9;
        cnt = 0;
        for (i = 0; i < ALLADCHANNELS; i++)
        {
            if ((Savech[i].polIndex >= 0) && (Savech[i].polIndex < BOCON_NO_OF_POL))
            {
                data.f = Savech[i].val;
                TcpBuf[index++] = data.ch[3];
                TcpBuf[index++] = data.ch[2];
                TcpBuf[index++] = data.ch[1];
                TcpBuf[index++] = data.ch[0];
                ++cnt;
                if (cnt * 4 >= regCount.i * 2) break;
            }
        }
        tcp_tlen[no] = index;
        root2xmem(tcp_tbuf[no], TcpBuf, tcp_tlen[no]);
    }
}


/*** BeginHeader modbusRS485Task*/
void modbusRS485Task(char COM_NUMBER);
/*** EndHeader */
void modbusRS485Task(char COM_NUMBER)
{
//   #define COM_NUMBER   1
    auto unsigned int crc;
    auto char crc1, crc2;
    auto CHARTOINTTY regAddr; //读寄存器开始地址
    auto CHARTOINTTY regCount; //读寄存器数量
    auto unsigned int stratAddr;
    auto unsigned int count;
    auto char p, i, k;
    auto union uf data;
    auto char fluxPos;     //瞬时流量的位置
    auto char fluxFlag;   //1-查询到瞬时流量在什么位置
    auto char codeCount;  //统计一共有多少个污染物
    auto float totalFlux;

    costate
    {
        com_open(COM_NUMBER, ai_param[COM_NUMBER+8].baudrate); //用指定的波特率打开串口
        com_databits(COM_NUMBER, PARAM_8BIT);           //8个数据位，PARAM_7BIT
        com_parity(COM_NUMBER, ai_param[COM_NUMBER + 8].parity); //校验位，0,1,2,3
        msDelay(20);
        while (1)
        {
            com_read(COM_NUMBER);
            if ((com_rlen >= 8) && (com_rbuf[0] == modbusConfig[COM_NUMBER].devAddr) && (com_rbuf[1] == 0x03))
            {
                crc = msrCRC(com_rbuf, 6);
                crc1 = (char)(crc >> 8);    //高位
                crc2 = (char)(crc & 0xff);  //低位
                if (com_rbuf[6] == crc1 && com_rbuf[7] == crc2)
                {
                    regAddr.c[1] = com_rbuf[2];  //地址
                    regAddr.c[0] = com_rbuf[3];
                    //stratAddr = (regAddr.i - 499) / 2;//计算出要读取第几个数据

                    regCount.c[1] = com_rbuf[4]; //数量
                    regCount.c[0] = com_rbuf[5];

                    com_tbuf[0] = modbusConfig[COM_NUMBER].devAddr;
                    com_tbuf[1] = 0x03;
                    com_tbuf[2] = 0x00;

                    count = 499;   //开始地址是500
                    totalFlux = 0.0;
                    for (i = 0; i < ALLADCHANNELS; i++)
                    {
                        if (Savech[i].polIndex == 81)
                        {
                            totalFlux = Savech[i].val;
                            break;
                        }
                    }
                    for (i = 0, k = 3; i < ALLADCHANNELS; i++)
                    {
                        if ((Savech[i].polIndex >= 0) && (Savech[i].polIndex < BOCON_NO_OF_POL / 2))
                        {
                            count += 2;
                            if (com_tbuf[2] >= regCount.i * 2) break;
                            if (count >= regAddr.i)
                            {
                                if (Savech[i].zs_index < ALLADCHANNELS)    //本通道有折算值
                                {
                                    /*data.f = Savech[i].val;
                                    com_tbuf[k++] = data.ch[1];
                                    com_tbuf[k++] = data.ch[0];
                                    com_tbuf[k++] = data.ch[3];
                                    com_tbuf[k++] = data.ch[2];
                                    data.f = Savech[Savech[i].zs_index].val;
                                    com_tbuf[k++] = data.ch[1];
                                    com_tbuf[k++] = data.ch[0];
                                    com_tbuf[k++] = data.ch[3];
                                    com_tbuf[k++] = data.ch[2];    */
                                    k = setRegFloatValue(COM_NUMBER, Savech[i].val, k);
                                    k = setRegFloatValue(COM_NUMBER, Savech[Savech[i].zs_index].val, k);
                                    com_tbuf[2] += 8;
                                }
                                else
                                {
                                    if (Savech[i].polIndex == 0)
                                    {
                                        /*data.f = Savech[i].val;
                                        com_tbuf[k++] = data.ch[1];
                                        com_tbuf[k++] = data.ch[0];
                                        com_tbuf[k++] = data.ch[3];
                                        com_tbuf[k++] = data.ch[2];
                                        data.f = onemsg_wr.AI_Val[i].Total;
                                        com_tbuf[k++] = data.ch[1];
                                        com_tbuf[k++] = data.ch[0];
                                        com_tbuf[k++] = data.ch[3];
                                        com_tbuf[k++] = data.ch[2]; */
                                        k = setRegFloatValue(COM_NUMBER, Savech[i].val, k);
                                        k = setRegFloatValue(COM_NUMBER, onemsg_wr.AI_Val[i].Total, k);
                                        com_tbuf[2] += 8;
                                    }
                                    else
                                    {
                                        /*data.f = Savech[i].val;
                                        com_tbuf[k++] = data.ch[1];
                                        com_tbuf[k++] = data.ch[0];
                                        com_tbuf[k++] = data.ch[3];
                                        com_tbuf[k++] = data.ch[2];*/
                                        k = setRegFloatValue(COM_NUMBER, Savech[i].val, k);
                                        com_tbuf[2] += 4;
                                    }
                                }
                            }
                        }
                    } //for(i=0; i<ALLADCHANNELS; i++)

                    crc = msrCRC(com_tbuf, k);
                    com_tbuf[k++] = (char)(crc >> 8);    //高位
                    com_tbuf[k++] = (char)(crc & 0xff);  //低位

#ifdef DEBUG_PRINTF
                    for (i = 0; i < k; i++)
                    {
                        printf("%02X ", com_tbuf[i]);
                    }
                    printf(" \n");
#endif

                    com_tlen = k;          //发送数据长度
                    com_write(COM_NUMBER);
                }
            }
            waitfor(DelayMs(1000));
        } //end of while
    }
}

/*** BeginHeader getModbusData*/
unsigned getModbusData(unsigned index, char port);
/*** EndHeader */
unsigned getModbusData(unsigned index, char port)
{
    union uf data, vaule;
    float f;
    char ch;
    data.f = 0.0;
    vaule.f = 0.0;

    if (index >= BOCON_NO_OF_POL)
    {
        return 0;
    }
    else
    {
        if (getSampleChannel(PolCode[index / 2], &ch, 1, &f) == 1)
        {
            data.f = f;
            if (modbusConfig[port].dataSort == DT_FLOAT)
            {
                vaule.ch[1] = data.ch[1];
                vaule.ch[0] = data.ch[0];
                vaule.ch[3] = data.ch[3];
                vaule.ch[2] = data.ch[2];
            }
            else if (modbusConfig[port].dataSort == DT_FLOAT_INVERSE)
            {
                vaule.ch[1] = data.ch[3];
                vaule.ch[0] = data.ch[2];
                vaule.ch[3] = data.ch[1];
                vaule.ch[2] = data.ch[0];
            }
            else if (modbusConfig[port].dataSort == DT_FLOAT_0123)
            {
                vaule.ch[1] = data.ch[0];
                vaule.ch[0] = data.ch[1];
                vaule.ch[3] = data.ch[2];
                vaule.ch[2] = data.ch[3];
            }
            else
            {
                vaule.ch[1] = data.ch[2];
                vaule.ch[0] = data.ch[3];
                vaule.ch[3] = data.ch[0];
                vaule.ch[2] = data.ch[1];
            }
        }
    }
    return vaule.i[index % 2];
}

/*** BeginHeader com_modbus_slave_task*/
void com_modbus_slave_task(char port);
/*** EndHeader */
void com_modbus_slave_task(char port)
{
    auto unsigned int crc;
    auto char crc1, crc2;
    auto CHARTOINTTY regAddr; //读寄存器开始地址
    auto CHARTOINTTY regCount; //读寄存器数量
    auto char i;
    auto char index;
    costate
    {
        com_open(port, ai_param[port + 8].baudrate); //用指定的波特率打开串口
        com_databits(port, PARAM_8BIT);           //8个数据位，PARAM_7BIT
        com_parity(port, ai_param[port + 8].parity); //校验位，0,1,2,3
        msDelay(20);
        while (1)
        {
            com_read(port);
            if ((com_rlen >= 8) && (com_rbuf[0] == modbusConfig[port].devAddr) && (com_rbuf[1] == 0x03 || com_rbuf[1] == 0x04))
            {
                crc = msrCRC(com_rbuf, 6);
                crc1 = (char)(crc >> 8);    //高位
                crc2 = (char)(crc & 0xff);  //低位
                if (com_rbuf[6] == crc1 && com_rbuf[7] == crc2)
                {
                    regAddr.c[1] = com_rbuf[2];
                    regAddr.c[0] = com_rbuf[3];
                    regCount.c[1] = com_rbuf[4];
                    regCount.c[0] = com_rbuf[5];

                    com_tbuf[0] = modbusConfig[port].devAddr;
                    com_tbuf[1] = com_rbuf[1];
                    com_tbuf[2] = regCount.i * 2;
                    index = 3;
                    for (i = 0; i < regCount.i; i++)
                    {
                        com_tbuf[index++] = getModbusData(regAddr.i + i, port) / 256;
                        com_tbuf[index++] = getModbusData(regAddr.i + i, port) % 256;
                    }
                    crc = msrCRC(com_tbuf, index);
                    com_tbuf[index++] = (char)(crc >> 8);    //高位
                    com_tbuf[index++] = (char)(crc & 0xff);  //低位
                    com_tlen = index;          //发送数据长度
                    com_write(port);
                }
            }
            waitfor(DelayMs(1000));
        }
    }
}

//00 00 00 00 00 04 01 01 01 03
/*** BeginHeader modbus_TCP_tasks_readDO*/
void modbus_TCP_tasks_readDO(char no);
/*** EndHeader */
void modbus_TCP_tasks_readDO(char no)
{
    auto char socket_tbuf[450];

    memset(socket_tbuf, 0x00, sizeof(socket_tbuf));
    xmem2root(deal_buf, tcp_rbuf[no], tcp_rlen[no]);
    if (deal_buf[6] == (char)devNo && tcp_rlen[no] > 7 && deal_buf[7] == 0x01)
    {
        if ((deal_buf[9] & 0x01) == 0x01)
        {
            digOut(0, 1);
        }
        else
        {
            digOut(0, 0);
        }

        if ((deal_buf[9] & 0x02) == 0x02)
        {
            digOut(1, 1);
        }
        else
        {
            digOut(1, 0);
        }
    }
}
/*** BeginHeader modbus_rtu_tasks_client*/
void modbus_rtu_tasks_client(char no);
/*** EndHeader */
void modbus_rtu_tasks_client(char no)
{
    auto int i, c;
    auto union uf data;
    auto float buf[200];
    auto char socket_tbuf[450];
    auto char addr, count;
    auto unsigned tmpcrc;

    memset(socket_tbuf, 0x00, sizeof(socket_tbuf));
    xmem2root(deal_buf, tcp_rbuf[no], tcp_rlen[no]);
    //memset(com_rbuf,0x00,sizeof(com_rbuf));
    //com_read(no);
    if (tcp_rlen[no] > 7 && (int)deal_buf[0] == devNo && deal_buf[1] == 0x03 && deal_buf[5] <= 0x0a)
    //if(com_rlen > 6 && com_rbuf[0] == (char)devNo && com_rbuf[1] == 0x03 && com_rbuf[3] == 0x01 && com_rbuf[5] <= 0x0a)
    {
        memset(buf, 0x00, sizeof(buf));
        for (i = 0; i < ALLADCHANNELS; i++)
        {
            if (Savech[i].polIndex >= 0 && Savech[i].polIndex < BOCON_NO_OF_POL)
            {
                buf[Savech[i].polIndex] = Savech[i].val;
            }
        }

        socket_tbuf[0] = (char)devNo;
        socket_tbuf[1] = 0x03;
        socket_tbuf[2] = deal_buf[5] * 2;
        addr = deal_buf[3];
        count = deal_buf[5];
        //for(c = addr,i = 0; c = c + 2,i++; c < addr + number,i < 7)
        for (c = addr,i = 0; i * 2 < count; i++, c = c + 2)
        {
            if (c > 199) break;
            data.f = buf[c / 2];
            socket_tbuf[3 + i * 4] = data.ch[3];
            socket_tbuf[4 + i * 4] = data.ch[2];
            socket_tbuf[5 + i * 4] = data.ch[1];
            socket_tbuf[6 + i * 4] = data.ch[0];
        }
        tmpcrc =  msrCRC(&socket_tbuf[0], socket_tbuf[2] + 3);
        tcp_tlen[no] = socket_tbuf[2] + 5;
        socket_tbuf[tcp_tlen[no] - 2] = (char)(tmpcrc >> 8);
        socket_tbuf[tcp_tlen[no] - 1] = (char)tmpcrc;
        root2xmem(tcp_tbuf[no], socket_tbuf, tcp_tlen[no]);
        //com_write(no);
        //msDelay(20);

    }
}
//00 00 00 00 00 0f 01 10 00 00 00 04 08 42 A0 00 00 42 44 00 00   写入实时数据
//00 00 00 00 00 06 01 01 00 00 00 04              读取DO
//00 00 00 00 00 06 01 05 00 09 ff 00 写入开关量数据
/*** BeginHeader modbus_tcp_tasks_client*/
void modbus_tcp_tasks_client(char no);
/*** EndHeader */
void modbus_tcp_tasks_client(char no)
{

    static int i;
    auto union uf data;
    static float buf[200];
    auto char socket_tbuf[100];
    static char count;

    costate
    {

        if (SEC_TIMER >= rtdInterval[no] + oldTime && TCP_OK[no] == 1)
        {
            oldTime = SEC_TIMER;
            memset(buf, 0x00, sizeof(buf));
            count = 0;
            for (i = 0; i < ALLADCHANNELS; i++)
            {
                if (Savech[i].polIndex >= 0 && Savech[i].polIndex < BOCON_NO_OF_POL)
                {
                    buf[count] = Savech[i].val;
                    count++;
                }

            }
            for (i = 0; i < count; i++)
            {
                memset(socket_tbuf, 0x00, sizeof(socket_tbuf));
                socket_tbuf[6] = (char)devNo;
                socket_tbuf[7] = 0x10;
                socket_tbuf[11] = 0x02;
                socket_tbuf[12] = 0x04;
                socket_tbuf[5] = socket_tbuf[12] + 7;

                data.f = buf[i];
                socket_tbuf[13] = data.ch[3];
                socket_tbuf[14] = data.ch[2];
                socket_tbuf[15] = data.ch[1];
                socket_tbuf[16] = data.ch[0];
                socket_tbuf[9] = (char)i * 2;
                tcp_tlen[no] = socket_tbuf[5] + 6;
                root2xmem(tcp_tbuf[no], socket_tbuf, tcp_tlen[no]);
                waitfor(DelaySec(1));
            }

            memset(socket_tbuf, 0x00, sizeof(socket_tbuf));
            socket_tbuf[6] = (char)devNo;
            socket_tbuf[7] = 0x01;
            socket_tbuf[9] = 0x00;
            socket_tbuf[11] = 0x04;
            socket_tbuf[5] = 0x06;
            tcp_tlen[no] = 12;
            root2xmem(tcp_tbuf[no], socket_tbuf, tcp_tlen[no]);
            waitfor(DelaySec(1));

            for (i = 0; i < 8; i++)
            {
                Poldi = (char)digInBank();
                memset(socket_tbuf, 0x00, sizeof(socket_tbuf));
                socket_tbuf[6] = (char)devNo;
                socket_tbuf[7] = 0x05;
                socket_tbuf[9] = 0x08 + (char)i;
                if ((Poldi >> i) & 0x01 == 0x01)
                {
                    socket_tbuf[10] = 0xff;
                }

                socket_tbuf[5] = 0x06;
                tcp_tlen[no] = 12;
                root2xmem(tcp_tbuf[no], socket_tbuf, tcp_tlen[no]);
                waitfor(DelaySec(1));
            }
        }
    }
}

/*** BeginHeader HexCharToDec */
int   HexCharToDec(char c_num);
/*** EndHeader */
int   HexCharToDec(char c_num)
{
    if ((c_num >= '0') && (c_num <= '9')) return (c_num - '0');
    else if ((c_num >= 'a') && (c_num <= 'f')) return (c_num - 'a' + 10);
    else if ((c_num >= 'A') && (c_num <= 'F')) return (c_num - 'A' + 10);
    else return -1;
}

/*** BeginHeader pack_modbus_cmd */
char pack_modbus_cmd(char devAddr, char cmd, int reg, int cnt);
/*** EndHeader */
char pack_modbus_cmd(char devAddr, char cmd, int reg, int cnt)
{
    auto unsigned int crc;

    com_tbuf[0] = devAddr;
    com_tbuf[1] = cmd;
    com_tbuf[2] = (char)(reg >> 8);
    com_tbuf[3] = (char)(reg & 0xff);
    com_tbuf[4] = (char)(cnt >> 8);
    com_tbuf[5] = (char)(cnt & 0xff);
    crc = msrCRC(com_tbuf, 6);
    com_tbuf[6] = (char)(crc >> 8);
    com_tbuf[7] = (char)(crc & 0xff);
    com_tlen = 8;
}

/*** BeginHeader pack_string_cmd */
char pack_string_cmd(char *pbuf);
/*** EndHeader */
char pack_string_cmd(char *pbuf)
{
    memset(com_tbuf, 0x00, sizeof(com_tbuf));
    strcpy(com_tbuf, pbuf);
    com_tlen = strlen(pbuf);
}

/*** BeginHeader int2hex */
char int2hex(int data);
/*** EndHeader */
char int2hex(int data)
{
    auto int n;
    n = (data / 10) * 0x10 + data % 10;
    return (char)n;
}

/*** BeginHeader hex2dec */
char hex2dec(char c);
/*** EndHeader */
char hex2dec(char c)
{
    auto char n;
    n = (c / 0x10) * 10 + c % 0x10;
    return n;
}
/*** BeginHeader dec2hex */
char dec2hex(int c);
/*** EndHeader */
char dec2hex(int c)
{
    auto int n;
    n = (c / 10) * 16 + (c % 10);
    return (char)n;
}
/*** BeginHeader strhexTohex*/
char strhexTohex(char c);
/*** EndHeader */
char strhexTohex(char c)
{
    if ((c >= 0x30) && (c <= 0x39))
    {
        c = c - 0x30;
    }
    else if ((c >= 0x41) && (c <= 0x46))
    {
        c = c - 0x37;
    }
    else if (c >= 0x61 && c <= 0x66)
    {
        c = c - 0x57;
    }

    return c;
}

/*** BeginHeader calZsValueV1_1*/
float calZsValueV1_1(char p);
/*** EndHeader */
float calZsValueV1_1(char p)
{
    auto char ch;
    auto float f1, f2, f3;
    auto float zsValue;
    auto float f;
    auto float dat_f1;
    auto long dat_l;

    zsValue = 0.0;
    //查找折算值
    f3 = extendData[4];   //测点实测的过量空气系数
    if (getSampleChannel("S01", &ch, 1, &f2) != 1)  goto RETURN_MARK;

    if (devNo == 101)
    {
        if (f2 >= extendData[7]) goto RETURN_MARK;
    }
    else if (devNo == 102)
    {
        if (f2 >= extendData[7])
        {
            if (getSampleChannel(PolCode[p], &ch, 1, &f) == 1)
            {
                zsValue = f;
            }
            goto RETURN_MARK;
        }
    }

    f2 = 21.0 - f2;
    if ((f2 <= 0.0) || (f3 <= 0.0))  goto RETURN_MARK;

    dat_f1 = (21.0 / f2);
    dat_l = (long)(dat_f1 * 100 + 0.5);
    dat_f1 = (float)(dat_l) / 100;      //取2位小数

    f2 = (dat_f1 / f3);
    dat_l = (long)(f2 * 100 + 0.5);
    f2 = (float)dat_l / 100;            //取2位小数


//    f2 = (21.0 / f2) / f3;
    if (getSampleChannel(PolCode[p], &ch, 1, &f1) != 1)  goto RETURN_MARK;
    zsValue = f1 * f2;
    dat_l = (long)(zsValue * 100 + 0.5);
    zsValue = (float)dat_l / 100;       //取2位小数

RETURN_MARK:
    return zsValue;
}


/*** BeginHeader calZsValueV1*/
float calZsValueV1(char p);
/*** EndHeader */
float calZsValueV1(char p)
{
    auto char ch;
    auto float f1, f2, f3;
    auto float zsValue;
    auto float f;

    zsValue = 0.0;
    //查找折算值
    f3 = extendData[4];   //测点实测的过量空气系数
    if (getSampleChannel("S01", &ch, 1, &f2) != 1)  goto RETURN_MARK;

    if (devNo == 101)
    {
        if (f2 >= extendData[7]) goto RETURN_MARK;
    }
    else if (devNo == 102)
    {
        if (f2 >= extendData[7])
        {
            if (getSampleChannel(PolCode[p], &ch, 1, &f) == 1)
            {
                zsValue = f;
            }
            goto RETURN_MARK;
        }
    }

    f2 = 21.0 - f2;
    if ((f2 <= 0.0) || (f3 <= 0.0))  goto RETURN_MARK;

    f2 = (21.0 / f2) / f3;
    if (getSampleChannel(PolCode[p], &ch, 1, &f1) != 1)  goto RETURN_MARK;
    zsValue = f1 * f2;

RETURN_MARK:
    return zsValue;
}

/*** BeginHeader calZsValueV2*/
float calZsValueV2(char p, char ver);
/*** EndHeader */
float calZsValueV2(char p, char ver)
{
    auto char ch;
    auto float Cs, Csn, Csng, as;
    auto float zsValue;
    auto float S03, S08, S05, S01, S01g;
    auto float f;
    zsValue = 0.0;
    //获取读取值
    as = extendData[4];   //测点实测的过量空气系数
    if (getSampleChannel("S01", &ch, 1, &S01) != 1)  goto RETURN_MARK;
    if (getSampleChannel("S03", &ch, 1, &S03) != 1)  goto RETURN_MARK;
    if (getSampleChannel("S05", &ch, 1, &S05) != 1)  goto RETURN_MARK;
    if (getSampleChannel("S08", &ch, 1, &S08) != 1)  goto RETURN_MARK;
    if (getSampleChannel(PolCode[p], &ch, 1, &Cs) != 1)  goto RETURN_MARK;

    if (devNo == 101)
    {
        if (S01 >= extendData[7]) goto RETURN_MARK;
    }
    else if (devNo == 102)
    {
        if (S01 >= extendData[7])
        {
            if (getSampleChannel(PolCode[p], &ch, 1, &f) == 1)
            {
                zsValue = f;
            }
            goto RETURN_MARK;
        }
    }

    if (dataUnit.s08 == S08_UNIT_KPA)
    {
        S08 *= 1000.0;
    }
    else if (dataUnit.s08 == S08_UNIT_MPA)
    {
        S08 *= 1000000.0;
    }

    if (extendData[2] + S08 <= 0)  goto RETURN_MARK;
    if (273.0 + S03 <= 0)  goto RETURN_MARK;
    if (S01 >= 21.0 || S01 <= 0)  goto RETURN_MARK;
    if (as <= 0.0)  goto RETURN_MARK;

    Csn = Cs * (101325.0 / (extendData[2] + S08)) * ((273.0 + S03) / 273.0);
    Csng = Csn / (1 - (S05 / 100.0));
    if (ver == 2) S01g = S01 / (1 - (S05 / 100.0));
    else S01g = S01;

    if (S01g >= 21.0 || S01g <= 0)  goto RETURN_MARK;
    zsValue = Csng * (21.0 / (21.0 - S01g)) / as;

RETURN_MARK:
    return zsValue;
}


/*** BeginHeader rd_calZsValue*/
int rd_calZsValue(char port, char ver);
/*** EndHeader */
int rd_calZsValue(char port, char ver)
{
    auto char p;
    auto char offset;
    auto char i, ch;

    for (i = 0; i < 20; i++)
    {
        p = BOCON_NO_OF_POL;
        if (i == 0)
        {
            p = ai_param[port + 8].polIndex;
            offset = 0;
        }
        else
        {
            for (ch = 0; ch < 20; ch++)
            {
                if (ai_param_extend[ch].polIndex >= BOCON_NO_OF_POL) continue; //判断这通道有没有使用
                if (ai_param_extend[ch].port != port) continue; //判断是否是对应的串口
                if (ai_param_extend[ch].position != i) continue; //位置是否对应
                p = ai_param_extend[ch].polIndex;
                offset = ai_param_extend[ch].position;
                break;
            }
        }

        if (p >= BOCON_NO_OF_POL / 2 && p < BOCON_NO_OF_POL)
        {
            if (ver == 2 || ver == 3)
            {
                com_f[offset] = calZsValueV2(p - 100, ver);
            }
            else
            {
#if(JIAOTONGWUZI == 1)
                com_f[offset] = calZsValueV1_1(p - 100);
#else
                com_f[offset] = calZsValueV1(p - 100);
#endif
            }
        }
    }

    com_sec = read_rtc();

    return 1;
}

/*** BeginHeader calS02V2*/
int calS02V2(char port);
/*** EndHeader */
int calS02V2(char port)
{
    auto char flag;
    auto float jueyaVal, gen;

    getAI(7, &com_f[0], &flag);
    jueyaVal = com_f[0];
    if (jueyaVal < 0) jueyaVal = 0.0 - jueyaVal; //取其绝对值
    gen = (jueyaVal * 2) / 1.35;

    if (gen >= 0)
    {
        gen = sqrt(gen);
        com_f[0] = 1.335 * gen * 0.84 * extendData[0]; //最后乘以速度场系数
    }
    else
    {
        com_f[0] = 0.0;
    }

    com_sec = read_rtc();

    return 1;
}


/*** BeginHeader getSampleChannel*/
int getSampleChannel(char code[], char *channel, char flag, float *value);
/*** EndHeader */
/*******************************************************************************
函数功能:根据编码查找对应的采集通道
参数1:需要查找的编码
参数2:对应的采集通道
参数3:1是实时数据，0是历史数据
返回:1表示查找到,0表示没有查找到
*******************************************************************************/
int getSampleChannel(char code[], char *channel, char flag, float *value)
{
    auto char i;
    auto unsigned char p;
    auto int status;

    status = 0;
    if (flag == 1)
    {
        for (i = 0; i < ALLADCHANNELS; i++)
        {
            if ((Savech[i].polIndex >= 0) && (Savech[i].polIndex < BOCON_NO_OF_POL / 2))
            {
                p = Savech[i].polIndex;
                if (strcmp(PolCode[p], code) == 0)
                {
                    *channel = i;
                    status = 1;
                    *value = Savech[i].val;
                    break;
                }
            }
        }
    }
    else if (flag == 0)
    {
        for (i = 0; i < ALLADCHANNELS; i++)
        {
            if ((onemsg_rd.AI_Val[i].polIndex >= 0) && (onemsg_rd.AI_Val[i].polIndex < BOCON_NO_OF_POL / 2))
            {
                p = onemsg_rd.AI_Val[i].polIndex;
                if (strcmp(PolCode[p], code) == 0)
                {
                    *channel = i;
                    status = 1;
                    *value = onemsg_rd.AI_Val[i].Avg;
                    break;
                }
            }
        }
    }

    return status;
}

/*** BeginHeader rd_qingheB02Biaotai*/
int rd_qingheB02Biaotai(char port);
/*** EndHeader */
int rd_qingheB02Biaotai(char port)
{
    auto char ch;
    auto float f1, S03, S08, S05;

    if ((getSampleChannel("S02", &ch, 1, &f1) == 1) &&
        (getSampleChannel("S03", &ch, 1, &S03) == 1) &&
        (getSampleChannel("S08", &ch, 1, &S08) == 1) &&
        (getSampleChannel("S05", &ch, 1, &S05) == 1))
    {
        com_f[0] = extendData[3] * f1; //得到工况流量 ，单位m3/h
        if (dataUnit.s08 == S08_UNIT_KPA)
        {
            S08 *= 1000.0;
        }
        else if (dataUnit.s08 == S08_UNIT_MPA)
        {
            S08 *= 1000000.0;
        }

        com_f[0] = com_f[0] * (273.0 / (273.0 + S03)) * ((extendData[2] + S08) / 101325) * (1 - (S05 / 100.0));

        if (dataUnit.b02 == B02_UNIT_M3H) com_f[0] *= 3600.0;
    }
    else
    {
        com_f[0] = 0.0;
    }
    com_sec = read_rtc();

    return 1;
}

/*** BeginHeader rd_qingheB02ReTai*/
int rd_qingheB02ReTai(char port);
/*** EndHeader */
int rd_qingheB02ReTai(char port)
{
    auto char ch;
    static float f1;

    if (getSampleChannel("S02", &ch, 1, &f1) == 1)
    {
        com_f[0] = extendData[3] * f1; //得到工况流量
        if (dataUnit.b02 == B02_UNIT_M3H) com_f[0] *= 3600.0;
    }
    else
    {
        com_f[0] = 0.0;
    }
    com_sec = read_rtc();

    return 1;
}

/*** BeginHeader get_hex */
char get_hex(char a1, char a2);
/*** EndHeader */
char get_hex(char a1, char a2) //给出两个ASCII值数据,返回共组成的一个hex值
{
    if (a1 >= 48 && a1 < 58) a1 -= 48;
    else if (a1 >= 65 && a1 < 71) a1 -= 55;
    else a1 = 0; //错误

    if (a2 >= 48 && a2 < 58) a2 -= 48;
    else if (a2 >= 65 && a2 < 71) a2 -= 55;
    else a2 = 0; //错误
    return ((a1 << 4) | (a2 & 0x0f));
}
/*******************************************************************************
湖北 和信 仪表驱动
flag = 1	读取瞬时流量、累计流量 				-- 2111
flag = 2	读取瞬时流量、累计流量、PH 	-- 2112
flag = 3	读取COD						-- 2113
flag = 4	读取氨氮						-- 2114
flag = 5	读取总磷						-- 2115

例：发送：0x02 000221054106B0B2 0x03
    返回：0x02 00022105000A4106005000D20000 0x03	瞬时流量：10，累计流量：5243090
*******************************************************************************/
/*** BeginHeader rd_flux_hexin */
int rd_flux_hexin(char port, char flag);
/*** EndHeader */
int rd_flux_hexin(char port, char flag)
{
    static int status;
    auto  CHARTOINTTY ic1;
    union uf ficl;
    auto unsigned long total;
    auto char *temp;
    auto char a1;
    auto char a2;

    costate
    {
        status = 0;             //初始化通讯状态标志位
        memset(com_tbuf, 0x00, sizeof(com_tbuf));
        com_tbuf[0] = 0x02;    //包头
        com_tbuf[1] = 0x30;    //功能代码 0x00
        com_tbuf[2] = 0x30;
        com_tbuf[3] = 0x30;    //污染因子代码个数
        switch (flag)
        {
        case 1:
            com_tbuf[4] = 0x32;    //污染因子代码个数 0x02					瞬时流量+累计流量
            com_tbuf[5] = 0x32;    //瞬时流量代码 0x2105
            com_tbuf[6] = 0x31;
            com_tbuf[7] = 0x30;
            com_tbuf[8] = 0x35;
            com_tbuf[9] = 0x34;    //累计流量代码 0x4106
            com_tbuf[10] = 0x31;
            com_tbuf[11] = 0x30;
            com_tbuf[12] = 0x36;
            com_tbuf[13] = 0x42;    //CRC 0xB0B2 (可用0000代替)
            com_tbuf[14] = 0x30;
            com_tbuf[15] = 0x42;
            com_tbuf[16] = 0x32;
            com_tbuf[17] = 0x03;    //包尾
            com_tlen = 18;          //发送数据长度
            break;
        case 2:
            com_tbuf[4] = 0x33;    //污染因子代码个数 0x03					瞬时流量+累计流量+PH
            com_tbuf[5] = 0x32;    //瞬时流量代码 0x2105
            com_tbuf[6] = 0x31;
            com_tbuf[7] = 0x30;
            com_tbuf[8] = 0x35;
            com_tbuf[9] = 0x34;    //累计流量代码 0x4106
            com_tbuf[10] = 0x31;
            com_tbuf[11] = 0x30;
            com_tbuf[12] = 0x36;
            com_tbuf[13] = 0x32;    //PH代码 0x2101
            com_tbuf[14] = 0x31;
            com_tbuf[15] = 0x30;
            com_tbuf[16] = 0x31;
            com_tbuf[17] = 0x30; //CRC 0x0403 (可用0000代替)
            com_tbuf[18] = 0x34;
            com_tbuf[19] = 0x30;
            com_tbuf[20] = 0x33;
            com_tbuf[21] = 0x03; //包尾
            com_tlen = 22;          //发送数据长度
            break;
        case 3:
            com_tbuf[4] = 0x31;    //污染因子代码个数 0x01					COD
            com_tbuf[5] = 0x32;    //COD代码 0x210B
            com_tbuf[6] = 0x31;
            com_tbuf[7] = 0x30;
            com_tbuf[8] = 0x42;
            com_tbuf[9] = 0x42;    //CRC 0xB38C
            com_tbuf[10] = 0x33;
            com_tbuf[11] = 0x38;
            com_tbuf[12] = 0x43;
            com_tbuf[13] = 0x03;    //包尾
            com_tlen = 14;          //发送数据长度
            break;
        case 4:
            com_tbuf[4] = 0x31;    //污染因子代码个数 0x01					氨氮
            com_tbuf[5] = 0x32;    //氨氮代码 0x213C
            com_tbuf[6] = 0x31;
            com_tbuf[7] = 0x33;
            com_tbuf[8] = 0x43;
            com_tbuf[9] = 0x46;    //CRC 0xF538
            com_tbuf[10] = 0x35;
            com_tbuf[11] = 0x33;
            com_tbuf[12] = 0x38;
            com_tbuf[13] = 0x03;    //包尾
            com_tlen = 14;          //发送数据长度
            break;
        case 5:
            com_tbuf[4] = 0x31;    //污染因子代码个数 0x01					总磷
            com_tbuf[5] = 0x32;    //总磷代码 0x2165
            com_tbuf[6] = 0x31;
            com_tbuf[7] = 0x36;
            com_tbuf[8] = 0x35;
            com_tbuf[9] = 0x33;    //CRC 0x3EE4
            com_tbuf[10] = 0x45;
            com_tbuf[11] = 0x45;
            com_tbuf[12] = 0x34;
            com_tbuf[13] = 0x03;    //包尾
            com_tlen = 14;          //发送数据长度
            break;
        default:
            break;
        }
        com_write(port);       //调用发送函数,将数据发送出去
        waitfor(DelayMs(1000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));  //清空接收缓冲区
        com_read(port);                            //调用接收函数,将数据放接收缓冲区中
        if (com_rlen >= 17)
        {
//2105	4106	2101	210B	213C	2165
            if ((flag == 1) || (flag == 2))
            {
                temp = strstr(com_rbuf, "2105");
                if (temp != NULL)
                {
                    temp += 4;
                    a1 = *temp;
                    temp++;
                    a2 = *temp;
                    temp++;
                    ic1.c[1] = get_hex(a1, a2);

                    a1 = *temp;
                    temp++;
                    a2 = *temp;
                    temp++;
                    ic1.c[0] = get_hex(a1, a2);
                    com_f[0] = ic1.i;           //瞬时流量
                }
                temp = strstr(com_rbuf, "4106");
                if (temp != NULL)
                {
                    temp += 4;
                    a1 = *temp;
                    temp++;
                    a2 = *temp;
                    temp++;
                    ficl.ch[3] = get_hex(a1, a2);

                    a1 = *temp;
                    temp++;
                    a2 = *temp;
                    temp++;
                    ficl.ch[2] = get_hex(a1, a2);

                    a1 = *temp;
                    temp++;
                    a2 = *temp;
                    temp++;
                    ficl.ch[1] = get_hex(a1, a2);

                    a1 = *temp;
                    temp++;
                    a2 = *temp;
                    temp++;
                    ficl.ch[0] = get_hex(a1, a2);
                    com_f[1] = (float)ficl.l; //累计流量

                }
                if (flag == 2)
                {
                    temp = strstr(com_rbuf, "2101");
                    if (temp != NULL)
                    {
                        temp += 4;
                        a1 = *temp;
                        temp++;
                        a2 = *temp;
                        temp++;
                        ic1.c[1] = get_hex(a1, a2);

                        a1 = *temp;
                        temp++;
                        a2 = *temp;
                        temp++;
                        ic1.c[0] = get_hex(a1, a2);
                        com_f[2] = ic1.i;           //PH
                    }
                }
            }
            else if (flag == 3)
            {
                temp = strstr(com_rbuf, "210B");
                if (temp != NULL)
                {
                    temp += 4;
                    a1 = *temp;
                    temp++;
                    a2 = *temp;
                    temp++;
                    ic1.c[1] = get_hex(a1, a2);
                    a1 = *temp;
                    temp++;
                    a2 = *temp;
                    temp++;
                    ic1.c[0] = get_hex(a1, a2);
                    com_f[0] = ic1.i;               //COD
                    status = 1;
                }
            }
            else if (flag == 4)
            {
                temp = strstr(com_rbuf, "213C");
                if (temp != NULL)
                {
                    temp += 4;
                    a1 = *temp;
                    temp++;
                    a2 = *temp;
                    temp++;
                    ic1.c[1] = get_hex(a1, a2);
                    a1 = *temp;
                    temp++;
                    a2 = *temp;
                    temp++;
                    ic1.c[0] = get_hex(a1, a2);
                    com_f[0] = ic1.i / 100.0;           //氨氮
                    status = 1;
                }
            }
            else if (flag == 5)
            {
                temp = strstr(com_rbuf, "2165");
                if (temp != NULL)
                {
                    temp += 4;
                    a1 = *temp;
                    temp++;
                    a2 = *temp;
                    temp++;
                    ic1.c[1] = get_hex(a1, a2);
                    a1 = *temp;
                    temp++;
                    a2 = *temp;
                    temp++;
                    ic1.c[0] = get_hex(a1, a2);
                    com_f[0] = ic1.i;           //总磷
                    status = 1;
                }
            }
            status = 1;
        }
        else
        {
            status = 2;
            com_f[0] = 0.0;
            com_f[1] = 0.0;
        }
        com_sec = read_rtc();                   //采样时间
        if (status == 0) status = 1;
    }
    return status;
}


/*** BeginHeader isEnableMapRs485*/
char isEnableMapRs485(char port);
/*** EndHeader */
char isEnableMapRs485(char port)
{
    if (modbusConfig[port].map485 == 1)  //映射485
        return 6;
    else return port;
}
#define  _______________________________________
/*******************************************************************************
串口设备的入口函数
port值为0-6，对应K37的COM0-COM6
缺省为只读一个参数和一个时间值
如果本通道有多个参数，则全部一次性读出，并按照扩展配置自动赋值
1,COM0,COM1,COM6是独立的,不过COM1是调试下载程序的口,因此在调试的时候不可以用COM1,不然出错
2,COM2至COM5是共用的串口
*******************************************************************************/
/*** BeginHeader rd_com_dev */
int rd_com_dev(char comNo); //返1正常,返2不正常,返3非定义状态
/*** EndHeader */
int rd_com_dev(char comNo)
{
    static int status;
    static char port;

    costate
    {
        status = 0;
        //memset(dev_state,0x00,sizeof(dev_state));
        if ((comNo < 0) || (comNo > 6))  status = 3;    //串口号错误
        else
        {
            port = isEnableMapRs485(comNo);
            if (((ai_param[comNo + 8].model != 8014) &&
                 (ai_param[comNo + 8].model != 8016) &&
                 (ai_param[comNo + 8].model != 1009) &&
                 (ai_param[comNo + 8].model != 6998)) ||
                (comOpenSign[comNo] == 0))
            {
                comOpenSign[comNo] = 1;
                com_open(port, ai_param[port + 8].baudrate); //用指定的波特率打开串口
                com_databits(port, PARAM_8BIT);           //8个数据位，PARAM_7BIT
                com_parity(port, ai_param[port + 8].parity); //校验位，0,1,2,3
                com_rdFlush(port);
                com_wrFlush(port);
                msDelay(20);
            }

            memset(com_f, 0x00, sizeof(com_f));       //清空读缓冲区
            switch (ai_param[comNo + 8].model)           //解析设备型号
            {

            case 3333:         //通用标准MOBUS协议，功能码 04
                waitfor(status = rd_modbus(port, comNo, 4, 0));    //功能码 04
                break;
            case 4444:         //通用标准MOBUS协议，功能码 03
                waitfor(status = rd_modbus(port, comNo, 3, 0));    //功能码 03
                break;
            case 5555:
                waitfor(status = rd_modbus(port, comNo, 4, 1));    //功能码 04
                break;
            case 6666:
                waitfor(status = rd_modbus(port, comNo, 3, 1));    //功能码 03
                break;

#if (DEV_10001_10010 == 1)
            case 10001:
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, 1, 3, 0, 6, rd_hach_handleFunction));
                break;
            case 10002:
                waitfor(status = rd_modbus_rtu_protocol(port, 1, 3, 0, 5, DT_UNSIGNED, 0, 0));
                break;
            case 10003:
                waitfor(status = rd_modbus_rtu_protocol(port, 1, 3, 0, 5, DT_INT, 0, 0));
                break;
            case 10004:
                waitfor(status = rd_modbus_rtu_protocol(port, 1, 3, 0, 6, DT_FLOAT, 0, 0));
                break;
            case 10005:
                waitfor(status = rd_modbus_rtu_protocol(port, 1, 3, 0, 6, DT_FLOAT_INVERSE, 0, 0));
                break;
            case 10006:
                waitfor(status = rd_modbus_rtu_protocol(port, 1, 3, 0, 6, DT_FLOAT_0123, 0, 0));
                break;
            case 10007:
                waitfor(status = rd_modbus_rtu_protocol(port, 1, 3, 0, 6, DT_LONG, 0, 0));
                break;
            case 10008:
                waitfor(status = rd_modbus_rtu_protocol(port, 1, 3, 0, 6, DT_LONG_INVERSE, 0, 0));
                break;
            case 10009:
                waitfor(status = rd_modbus_rtu_protocol(port, 1, 3, 2, 6, DT_FLOAT, 0, 0));
                break;
            case 10010:
                waitfor(status = rd_modbus_rtu_protocol(port, 1, 3, 0, 6, DT_LONG_0123, 0, 0));
                break;
#endif

#define _____________________________________________________________________
            case 1001: //九波声迪 WL-1A(怡文协议)
            case 1002: //万华雷德 WL-1A1
                waitfor(status = rd_flux_jiubo(port));
                break;
            case 10011: //发波流量计MODBUS RTU协议
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, modbusConfig[comNo].devAddr, 3, 0, 8, rd_flux_jiubo_modbusRTU_handleFunction));
                break;
            case 1003: //青岛环科 SWC 小流量计
                waitfor(status = rd_flux_huanke(port));
                break;
            case 1004: //无锡求信流量计
                waitfor(status = rd_flux_qiuxin(port));
                break;
            case 1005: //沈阳兰申 MAG511系列
            case 1006: //上海光华的电磁流量计,,,与 沈阳兰申 MAG511系列一样. (注意只使用了沈阳兰申的子程序)
                waitfor(status = rd_flux_lanshen(port));
                break;
            case 1008: //大连西格玛，OC2000 3 Z3型超声波明渠流量计
                waitfor(status = rd_flux_xigema(port));
                break;
            case 1009: //重庆华正水文仪器有限公司
                waitfor(status = rd_flux_huazheng(port));
                break;

#if (DEV_1010_1011_1012 == 1)
            case 1010: //盛A
                waitfor(status = rd_flux_shenghua(port));
                break;
            case 1011: //汇谷
                waitfor(status = rd_flux_huigu(port));
                break;
            case 1012: //金源协议
                waitfor(status = rd_flux_jinyuan(port));
                break;
#endif
            case 1013: //HBML-3型流量计数据接口协议
                waitfor(status = rd_flow_hb(port));
                break;
            case 1014: //重庆水文流量计协议 型号：WHZJ
                waitfor(status = rd_chongqing_shuiwen(port));
                break;
            case 1015: //西安三全
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, modbusConfig[comNo].devAddr, 3, 6, 6, rd_flux_1015sanquan));
                break;
            case 1016: //江苏太仓创造
                waitfor(status = rd_flux_taicang(port));
                break;
            case 1017: //
                waitfor(status = rd_flux_boersi(port)); //大连博克斯流量计
                break;

#if (DEV_10321_10322 == 1)
            case 10321: //江苏博克斯流量计V2版
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, modbusConfig[comNo].devAddr, 3, 2, 4, rd_flux_10321boersi));
                break;
#endif

#if (DEV_1018_1021_1022 == 1)
            case 1018: //
                waitfor(status = rd_flux_boersi_v2(port));
                break;
            case 1021: //西门子流量子
                waitfor(status = rd_multiranger_cod(port));
                break;
            case 1022: //江苏 明渠流量计
                waitfor(status = rd_flux_jiangsu(port));
                break;
#endif
#if (GUANGZHOUXINHUAN == 1)
            case 10202: //广州新环，原宁波东驰驱动
                waitfor(status = rd_flux_lmag(port));
                break;
            case 10322: //L-mag电磁流量计
                waitfor(status = rd_flux_L_mag(port, modbusConfig[comNo].devAddr));
                break;
#endif


#if (0)
            case 1024: //禹治环保 流量计
                waitfor(status = rd_flux_yuzhiFM(port));
                break;
#endif

#if (DEV_1023_1033 == 1)
            case 1023: //西安交大长天流量计
                waitfor(status = rd_flux_changtian(port));
                break;
            case 1025: //鸿恺流量计
                waitfor(status = rd_flux_hongkai(port));
                break;
            case 1026: //天信
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, 2, 3, 1, 6, rd_flux_1026tianxin));
                break;
            case 1029: //电磁流量计
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, 1, 3, 0, 7, rd_flux_1029dianci));
                break;
            case 1030: //绿洁流量计
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, 1, 3, 2, 6, rd_flux_1030lvjie));
                break;
            case 1031: //江门纬创流量计
                waitfor(status = rd_flux_weichuang(port));
                break;
            case 1032: //湖北中碧流量计
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, 1, 3, 1, 4, rd_flux_1032zhongbi));
                break;
            case 1033: //奇力流量积算仪
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, 1, 3, 2, 8, rd_flux_1033qili));
                break;
#endif
            case 1035: //广州奇宁化工
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, 2, 3, 0, 22, rd_flux_1035qining));
                break;



            case 1037: //MBMAG电磁流量计
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, 1, 3, 4112, 6, rd_flux_1037MBMAG));
                break;
            case 1038: //帆扬FYCS-2000
                waitfor(status = rd_modbus_ascii_protocol_define_handle(port, 1, 3, 0, 12, rd_flux_1038FYCS));
                break;

#if (DEV_1043_1044 == 1)
            case 1043: //金湖金诺
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, 1, 3, 8, 4, rd_flux_1043jinhujinnuo));
                break;
            case 1044: //IFC050流量计
                waitfor(status = rd_fulx_IFC050(port));
                break;
#endif



#if (SHIYONGWUJIN == 1)
            case 1045: //东文流量计 新协议
                waitfor(status = rd_flux_dongwen(port));
                break;
            case 1046: //东文流量计 协议
                waitfor(status = rd_flux_dongwen_1(port));
                break;
#endif



#if (DEV_1998_1999 == 1)
            case 1998:
                waitfor(status = rd_cod_weishuicod060one(port));
                break;
            case 1999:
                waitfor(status = rd_cod_weishuicod060(port));
                break;
#endif
            case 2001: //哈希COMmax
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, modbusConfig[comNo].devAddr, 3, 0, 6, rd_hach_handleFunction));
                break;

            case 2002: //广州怡文 EST-2001B
                waitfor(status = rd_cod_yiwen(port));
                break;
            case 20022: //广州怡文  有两位小数点显示
                waitfor(status = rd_yiwen_andan_cod(modbusConfig[comNo].devAddr, port));
                break;
            case 2003: //岛津      TOC-4100CN
                waitfor(status = rd_cod_daojin(port));
                break;
            case 2004: //河北先河  UVCOD
                waitfor(status = rd_cod_xianhe(port, 1));
                break;
            case 2005: //北京普析  TW-6000
                waitfor(status = rd_cod_puxi(port));
                break;
            case 2006:
                waitfor(status = rd_num_huashijie(port));
                break;

            case 2008: //兰州连华  5B-5
                waitfor(status = rd_cod_lianhua(port));
                break;
            case 2009: //北京环科COD
                waitfor(status = rd_cod_huanke(port));
                break;
            case 2010: //南京鸿恺
                waitfor(status = rd_cod_hongkai(port));
                break;
            case 20101: //南京鸿凯新协议
                waitfor(status = rd_cod_hongkai_new(port));
                break;
#if (DEV_2011_2012 == 1)
            case 2011: //泽美是松下电工MEW协议，所以取消
                waitfor(status = rd_cod_zemei(port));
                break;
            case 2012: //济南大陆机电股份有限公司
                waitfor(status = rd_cod_dalujidian(port));
                break;
#endif
            case 2013: //南京锐泉环保技术有限公司 RenQ-IV型COD在线分析仪通信协议
                waitfor(status = rd_cod_ruiquan(port));
                break;
            case 2014: //宇星,除以100
                waitfor(status = rd_cod_yuxing(port, modbusConfig[comNo].ratedata));
                break;
            case 2015: //德莱
                waitfor(status = rd_cod_delai(port));
                break;
            case 2016: //爱华仪器
                waitfor(status = rd_modbus_rtu_protocol(port, 1, 3, 6808, 4, DT_FLOAT_INVERSE, 0, 0));
                break;

#if (DEV_2017_2018_2019 == 1)
            case 2017: //世纪天源
                waitfor(status = rd_cod_tianyuan(port));
                break;
            case 2018: //JHC型COD通讯协议      河南乾正环保设备有限公司
                waitfor(status = rd_cod_jhc(port, modbusConfig[comNo].ratedata));
                break;
            case 2019: //YSM-C型COD的通讯协议
                waitfor(status = rd_cod_YSM_C(port));
                break;
#endif
#if (DEV_2020_20221 == 1)
            case 2020: //TETHYS环保设备串口通讯协议
                waitfor(status = rd_modbus_rtu_protocol(port, 1, 3, 0x1C, 4, DT_FLOAT, 0, 0));
                break;
            case 20201: //TETHYS环保设备串口通讯协议
                waitfor(status = rd_modbus_rtu_protocol(port, 1, 3, 36, 4, DT_FLOAT, 0, 0));
                break;
            case 2021: //无锡创辰科技重金属仪器
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, 1, 4, 2, 9, rd_2021_ahong2hao));
                break;
            case 2022: //德林COD分析仪 (博克斯南京协议)
                waitfor(status = rd_cod_delin(port, 0));
                break;
            case 20221: //德林COD分析仪 (博克斯南京协议) 乘以10
                waitfor(status = rd_cod_delin(port, 1));
                break;
#endif
            case 2024: //河北先河
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, 1, 3, 10, 2, rd_cod_2024xianhe));
                break;
            case 2029: //华时捷在线监测仪
                waitfor(status = rd_num_huashijie(port));
                break;
            case 2030: //无锡创晨COD,氨氮
                waitfor(status = rd_cod_wumingCOD(port, modbusConfig[comNo].ratedata));
                break;
            case 2032: //雪迪龙
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, 1, 4, 0, 9, rd_cod_2032xuedilong));
                break;

            case 2034: //港能/松下/中绿
                waitfor(status = rd_device_gangneng_songxia_zhonglv(port, modbusConfig[comNo].devAddr, modbusConfig[comNo].ratedata));
                break;
            case 2035: //厚天协议
                waitfor(status = rd_cod_modbusascii(port, modbusConfig[comNo].devAddr));
                break;

#if(SUZHOUWEISHUI == 1)
            case 2037: //卫水
                waitfor(status = rd_device_weishui(port));
                break;
            case 2137: //卫水
                waitfor(status = rd_device_weishui_v2(port));
                break;
            case 2237: //卫水
                waitfor(status = rd_device_weishui_v3(port));
                break;
            case 2337: //卫水
                waitfor(status = rd_device_weishui_v4(port, 1));
                break;
#endif
            case 2040:
                waitfor(status = rd_some_huashijie(port));
                break;
            case 2050:
                waitfor(status = rd_some_huashijie_modbus(port));
                break;
            case 2051:
                waitfor(status = rd_cod_huachen(port));
                break;

#if (DEV_2111_2112_2113_2114_2115 == 1)
            case 2111: //读瞬时流量、累计流量
                waitfor(status = rd_flux_hexin(port, 1));
                break;
            case 2112: //读瞬时流量、累计流量、PH
                waitfor(status = rd_flux_hexin(port, 2));
                break;
            case 2113: //读COD
                waitfor(status = rd_flux_hexin(port, 3));
                break;
            case 2114: //读氨氮
                waitfor(status = rd_flux_hexin(port, 4));
                break;
            case 2115: //读总磷
                waitfor(status = rd_flux_hexin(port, 5));
                break;
#endif
            case 2070:
                waitfor(status = rd_single_metal_yingsi(port, modbusConfig[comNo].ratedata, modbusConfig[comNo].devAddr));
                break;

#if (DEV_3001_3005 == 1)
            case 3001: //广州怡文 EST-2004 氨氮在线监测仪
                waitfor(status = rd_amm_yiwen(port));
                break;
            case 3002: //河北先河 氨氮在线监测仪
                waitfor(status = rd_cod_xianhe(port, 1));
                break;
            case 3003: //兰州连华 氨氮在线监测仪
                waitfor(status = rd_cod_lianhua(port));
                break;
            case 3004: //YSM-A氨氮仪器
                waitfor(status = rd_andan_YSM_C(port));
                break;
            case 3005: //EST2003总磷在线监测仪通讯格式
                waitfor(status = rd_tp_yiwen(port));
                break;
#endif
            case 3007:
                waitfor(status = rd_cod_elox100(port));
                break;
            case 3009: //江苏锐泉 RENQ-IV型 氨氮在线分析仪		20160812
                waitfor(status = rd_andan_ruiquan(port));
                break;
            case 3010: //岛津氨氮 读一个值
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, modbusConfig[comNo].devAddr, 4, 8, 22, rd_cod_3010daojinandan));
                break;
            case 3011: //岛津氨氮 读两个值
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, modbusConfig[comNo].devAddr, 4, 8, 22, rd_cod_3011daojinandan));
                break;
            case 3506:
                waitfor(status = rd_ZE_C310(port, modbusConfig[comNo].devAddr));
                break;


#if (DEV_4001_4002_4004_4005 == 1)
            case 4001: //哈希1950 plus TOC
                waitfor(status = rd_cod_hach(port));
                break;
            case 4002: //河北先河 TOC
                waitfor(status = rd_cod_xianhe(port, 1));
                break;
            case 4004: //岛津TOC-4100CN  (TOC)
                waitfor(status = rd_cod_daojin(port));
                break;
            case 4005:
                waitfor(status = rd_andan_TOC(port));
                break;
#endif

#if (DEV_4007_4008_4017 == 1)
            case 4007:
                waitfor(status = rd_daojin_andan(port));
                break;
            case 4008:
                waitfor(status = rd_UV4000(port));
                break;
            case 4017:
                waitfor(status = rd_4017(port, 1, comNo));
                break;
#endif

#if (DEV_5001 == 1)
            case 5001: //德国科泽 氰化物
                waitfor(status = rd_5001_metal_keze(port, modbusConfig[comNo].devAddr));
                break;
#endif


#if (DEV_6001_6008 == 1)
            case 6001: //德国科泽 镍
                waitfor(status = rd_metal_keze(port, 1));
                break;
            case 6002: //德国科泽 铜
                waitfor(status = rd_metal_keze(port, 2));
                break;
            case 6003: //广州怡文
                waitfor(status = rd_amm_yiwen(port));
                break;
            case 6004: //河北先河
                waitfor(status = rd_cod_xianhe(port, 1));
                break;
            case 6006: //湖南力合 总锰
                waitfor(status = rd_metal_lihe(port));
                break;
            case 6007: //DWG-8002A氨氮自动监测仪的MODBUS协议
                waitfor(status = rd_andan_dwg(port));
                break;
            case 6010: //无锡点创重金属
                waitfor(status = rd_modbus_rtu_protocol_define_handle(port, 1, 3, 4250, 8, rd_metal_6010dianchuang));
                break;
#endif

#if (DEV_6008_6016 == 1)
            case 6008: //powermon单参数仪表	(0x0a, 0x04, 0x10, 0x02); 0123
                waitfor(status = rd_metal_powermon(port));
                break;
            case 6016: //点创 (0x01, 0x04, 0x02, 0x02);	 1032
                waitfor(status = rd_xuanfuwu_dianchuang(port));
                break;
#endif


#if (DEV_7017_8009_8016 == 1)
            case 7017:
                waitfor(status = rd_7017(port, comNo));
                break;
            case 8008: //攀钢汇同
                waitfor(status = rd_fluxcod_huitong(port));
                break;
            case 8009: //攀钢汇同2.5
                waitfor(status = rd_fluxcod_huitong_v25(port));
                break;
            case 8016: //岛津烟气系统
                waitfor(status = rd_daojin_cems(port));
                break;
#endif
            case 8011: //计算折算值
                waitfor(status = rd_calZsValue(port, 1));
                break;
            case 8111: //计算折算值,计算数据需要湿转干
                waitfor(status = rd_calZsValue(port, 2));
                break;
            case 8211: //计算折算值,计算数据需要湿转干，但是氧含量不需要转
                waitfor(status = rd_calZsValue(port, 3));
                break;
            case 8012: //计算烟气热态流量
                waitfor(status = rd_qingheB02ReTai(port));
                break;
            case 8112: //计算烟气标态流量
                waitfor(status = rd_qingheB02Biaotai(port));
                break;
            case 8013: //计算烟流速
                waitfor(status = rd_qingheS02(port));
                break;
            case 8113: //根据压差进行计算流速
                waitfor(status = calS02V2(port));
                break;
            case 8014: //国标2011，串口是一直打开
                waitfor(status = rd_guobiao_2011(port, 1, modbusConfig[comNo].ratedata));
                break;
            case 8114: //延时33秒后，关闭串口
                waitfor(status = rd_guobiao_2011(port, 33, modbusConfig[comNo].ratedata));
                break;
            case 8214: //延时63秒后，关闭串口
                waitfor(status = rd_guobiao_2011(port, 63, modbusConfig[comNo].ratedata));
                break;

#if(JIAOTONGWUZI == 1)
            case 8229: //交彤物资
                waitfor(status = rd_cod_analog_v3(port, 1, comNo));
                break;
#endif



#if (DEV_8024_8025 == 1)
            case 8024: //希斯迪仪表协议
                waitfor(status = rd_cya_systea(port));
                break;
            case 8025: //青岛佳明
                waitfor(status = rd_jiaming_jmhm(port, modbusConfig[comNo].ratedata));
                break;
#endif
#if(XIJIANGHUANBAO == 1)
            case 8028: //西江环保 压力、差压计算流速的驱动
                waitfor(status = rd_S02_weichuang(port));
                break;
#endif

#if (DEV_8056_8156_8070 == 1)
            case 8056: //新疆协议、河北协议，污染物编码少于3位，有空格
                waitfor(status = rd_hebei_V2(port, 1, 3));
                break;	    case 8156: //新疆协议、河北协议，污染物编码少于3位，没有空格		waitfor(status = rd_hebei_V2(port, 0, 3));		break;	    case 8070:		waitfor(status = rd_fenxiyi_zetian(port));		break;
#endif


#if (ZHAOQINGLVTUO == 1)
            case 9994:
//		waitfor(status = rd_devicedriver_lihe(port));
                break;
            case 9995:
                waitfor(status = rd_device_nanjinghongkai(port));
                break;
            case 9996:
                waitfor(status = rd_device_htc_c(port));
                break;
            case 9997:
                waitfor(status = rd_wanyi_shuizhi(port));
                break;
            case 9998:
                waitfor(status = rd_modbus_wendu_jianceyi(comNo));
                break;
            case 9999:
                waitfor(status = rd_get_SO2());
                break;
#endif

#if(HANGZHOUHAICHI == 1)
            case 9999:
                waitfor(status = rd_andan_count());
                break;
#endif


#if (JIANGXIJIAHAOYONGSHENG == 1)
            case 9997:
                waitfor(status = rd_analyzer_xisidun(comNo));
                break;
#endif

#if (JAINGXIYIZHENG == 1 || JIANGXIJIAHAOYONGSHENG == 1)
            case 9998:
                waitfor(status = rd_wuxi_cod_andan(port, modbusConfig[comNo].devAddr, modbusConfig[comNo].ratedata));
                break;
            case 9999:
                waitfor(status = rd_JiangXiYiZheng_modbus(port, modbusConfig[comNo].devAddr, modbusConfig[comNo].ratedata));
                break;
#endif



#if (GUIZHOUCHENGDA == 1)//贵州成达
            case 9999:
                waitfor(status = rd_device_guizhouchegnda(port));
                break;
#endif

#if (JIANGXIBOYUAN == 1)
            case 9999:
                waitfor(status = rd_flux_JiangXiBoYuan(port, modbusConfig[comNo].devAddr));
                break;
#endif

#if (XIAMENLIANAOMEIYE == 1)
            case 9998:
                waitfor(status = rd_TNP4200(port, modbusConfig[comNo].devAddr));
                break;
            case 9999:
                waitfor(status = rd_485_more_instrument(port));
                break;
#endif

#if (KAIMINGKEJI == 1)
            case 9999:
                waitfor(status = rd_protocol_qianfen(port));
                break;
#endif

#if (JUGUANGKEJI == 1)
            case 9999:
                waitfor(status = rd_protocol_xisidun_serial(port, modbusConfig[comNo].devAddr));
                break;
#endif


#if (CHENGDUXINYITENG == 1)
            case 9999:
                waitfor(status = rd_SFGD_yanqi(port, 30));
                break;
#endif

#if (CHANGSHAHUASHIJIE == 1)	
			case 9998:
				waitfor(status = rd_device_countS02(port));
				break;
            case 9999:
                waitfor(status = rd_cems_huashijie(port));
                break;
#endif

#if (GUANGDONGTIANRUI == 1)  
          
            case 9999:
                waitfor(status = rd_TNP4200(port, modbusConfig[comNo].devAddr));
                break;
            case 11001:
                waitfor(status = rd_flux_jiubo_add_jiubo(port));
                break;
#endif

#if(NANJINGHONGLI == 1)
			
			case 9998:
				waitfor(status = rd_songxia(port));
				break;
			case 9999:
				waitfor(status = rd_flux_bosida(port,comNo,modbusConfig[comNo].devAddr));
				break;
#endif

#if(GUANGZHOUSHIJING == 1)			
			case 9999://上海光华的电磁流量计,,,与 沈阳兰申 MAG511系列一样. (注意只使用了沈阳兰申的子程序)
			   waitfor(status = rd_flux_GHmag_v1(port));
			   break;
#endif
			
#if(GUANGZHOUBIYUAN == 1)			
			case 9999://广州碧源，雨量计
			   waitfor(status = rd_flux_biyuan(port));
			   break;
#endif

			

			


            default:
                status = 3; //非定义状态
                break;
            }

            if ((ai_param[comNo + 8].model != 8014) &&
                (ai_param[comNo + 8].model != 8016) &&
                (ai_param[comNo + 8].model != 1009) &&
                (ai_param[comNo + 8].model != 6998))
            {
                com_close(port);     //完成数据采集，关闭串口
            }
            msDelay(50);         //延时50ms，等待串口底层驱动完全关闭
        }
    }
    return status;
}



/*** BeginHeader start_metal_powermon */   //布朗卢比
void start_metal_powermon(char port);
/*** EndHeader */
void start_metal_powermon(char port)
{
    //0a 10 00 00 00 02 04 0f 00 00 00 d5 9f

    com_tbuf[0] = 0x0A;
    com_tbuf[1] = 0x10;
    com_tbuf[2] = 0x00;
    com_tbuf[3] = 0x00;
    com_tbuf[4] = 0x00;
    com_tbuf[5] = 0x02;
    com_tbuf[6] = 0x04;
    com_tbuf[7] = 0x0F;
    com_tbuf[8] = 0x00;
    com_tbuf[9] = 0x00;
    com_tbuf[10] = 0x00;
    com_tbuf[11] = 0xD5;
    com_tbuf[12] = 0x9F;
    com_tlen = 13;
    com_write(port);

    msDelay(10000);

    com_read(port);

    //0a 10 00 00 00 02 04 0f 00 01 00 d4 0f
    com_tbuf[0] = 0x0A;
    com_tbuf[1] = 0x10;
    com_tbuf[2] = 0x00;
    com_tbuf[3] = 0x00;
    com_tbuf[4] = 0x00;
    com_tbuf[5] = 0x02;
    com_tbuf[6] = 0x04;
    com_tbuf[7] = 0x0F;
    com_tbuf[8] = 0x00;
    com_tbuf[9] = 0x01;
    com_tbuf[10] = 0x00;
    com_tbuf[11] = 0xD4;
    com_tbuf[12] = 0x0F;
    com_tlen = 13;
    com_write(port);

}


/*** BeginHeader start_cod_hongkai */
void start_cod_hongkai(char port);
/*** EndHeader */
void start_cod_hongkai(char port)
{
    memset(com_tbuf, 0x00, sizeof(com_tbuf));
    strcpy(com_tbuf, "%01#WDD02576025760100**");   //开始转换...
    com_tlen = strlen(com_tbuf);
    com_tbuf[com_tlen] = 0x0d; //最后以0x0d结束
    com_tlen++;
    com_write(port);
}

//开始测试 :命令 :01 06 00 33 00 01 B8 05
/*** BeginHeader start_cod_hach */
void start_cod_hach(char port);
/*** EndHeader */
void start_cod_hach(char port)
{
    pack_modbus_cmd(0x01, 0x06, 0x33, 0x01);
    com_write(port);
}

//开始测试 :命令 :20 06 00 16 00 01 af 7f
/*** BeginHeader start_cod_zetian */
void start_cod_zetian(char port);
/*** EndHeader */
void start_cod_zetian(char port)
{
    pack_modbus_cmd(0x20, 0x06, 0x16, 0x01);
    com_write(port);
}
//开始测试 :命令 :20 06 00 16 00 01 af 7f
/*** BeginHeader start_cod_zetian_ljg */
void start_cod_zetian_ljg(char port);
/*** EndHeader */
void start_cod_zetian_ljg(char port)
{
    pack_modbus_cmd(0x20, 0x06, 0x9c56, 0x01);
    com_write(port);
}

//01 05 08 1A FF 00 AF 9D
/*** BeginHeader start_device_htc_c */
void start_device_htc_c(char port);
/*** EndHeader */
void start_device_htc_c(char port)
{
    memset(com_tbuf, 0xff, sizeof(com_tbuf));
    com_tbuf[0] = 0x01;
    com_tbuf[1] = 0x05;
    com_tbuf[2] = 0x08;
    com_tbuf[3] = 0x1A;
    com_tbuf[4] = 0xFF;
    com_tbuf[5] = 0x00;
    com_tbuf[6] = 0xAF;
    com_tbuf[7] = 0x9D;
    com_tlen = 8;
    com_write(port);
}

//01 06 0A 10 00 01 4A 17
/*** BeginHeader start_device_nanjinghongkai */
void start_device_nanjinghongkai(char port);
/*** EndHeader */
void start_device_nanjinghongkai(char port)
{
    pack_modbus_cmd(0x01, 0x06, 0x0a10, 0x0001);
    com_write(port);
}

//3A 30 31 31 30 30 30 30 30 30 30 30 31 30 32 30 30 30 32 45 41 0D 0A
//3A 30 32 31 30 30 30 30 30 30 30 30 31 30 32 30 30 30 32 45 39 0D 0A
//3A 30 33 31 30 30 30 30 30 30 30 30 31 30 32 30 30 30 32 45 38 0D 0A


/*** BeginHeader start_device_wanyi */
void start_device_wanyi(char port);
/*** EndHeader */
void start_device_wanyi(char port)
{
    memset(com_tbuf, 0x00, sizeof(com_tbuf));
    strcpy(com_tbuf, ":011000000001020002EA\r\n");
    com_tlen = strlen(com_tbuf);
    com_write(port);
    msDelay(100);
    memset(com_tbuf, 0x00, sizeof(com_tbuf));
    strcpy(com_tbuf, ":021000000001020002E9\r\n");
    com_tlen = strlen(com_tbuf);
    com_write(port);
    msDelay(100);
    memset(com_tbuf, 0x00, sizeof(com_tbuf));
    strcpy(com_tbuf, ":031000000001020002E8\r\n");
    com_tlen = strlen(com_tbuf);
    com_write(port);
    msDelay(100);
}

/*** BeginHeader start_devicedriver_lihe*/
void start_devicedriver_lihe(char port);
/*** EndHeader */
void start_devicedriver_lihe(char port)
{
    auto union uf f; //uf这在K36的驱动库里已定义
    auto int regAddr; //寄存器地址
    auto char portPosition;
    auto char codePosition;
    static char slaveAdd;
    static int i;
    auto unsigned int crc;



    portPosition = port + 8;    //计算出是哪个通道的
    codePosition = ai_param[portPosition].polIndex;  //取出污染物编码位置
    slaveAdd = (char)atoi(calAddress(PolCode[codePosition])); //计算出MODBUS的寄存器地址
                                                              //pack_modbus_cmd(slaveAdd, 0x03, 0x00, 0x02);

    com_tbuf[0] = slaveAdd;
    com_tbuf[1] = 0x10;
    com_tbuf[2] = 0x00;
    com_tbuf[3] = 0x14;
    com_tbuf[4] = 0x00;
    com_tbuf[5] = 0x01;
    com_tbuf[6] = 0x02;
    com_tbuf[7] = 0x00;
    com_tbuf[8] = 0x01;

    crc = msrCRC(com_tbuf, 9);
    com_tbuf[9] = (char)(crc >> 8);
    com_tbuf[10] = (char)(crc & 0xff);
    com_tlen = 11;
    com_write(port);

    //waitfor(DelayMs(5000));
    msDelay(2000);

    memset(com_rbuf, 0x00, sizeof(com_rbuf));
    com_read(port);
    if ((com_rlen >= 2))
    {
        for (i = 0; i < 20; i++)
        {
            if (ai_param_extend[i].port == port) //是同一个串口的
            {
                codePosition = ai_param_extend[i].polIndex;
                if ((codePosition >= 0) && (codePosition < BOCON_NO_OF_POL))
                {
                    slaveAdd = (char)atoi(calAddress(PolCode[codePosition])); //计算出MODBUS的寄存器地址
                                                                              //pack_modbus_cmd(slaveAdd, 0x03, 0x00, 0x02);
                    com_tbuf[0] = slaveAdd;
                    com_tbuf[1] = 0x10;
                    com_tbuf[2] = 0x00;
                    com_tbuf[3] = 0x14;
                    com_tbuf[4] = 0x00;
                    com_tbuf[5] = 0x01;
                    com_tbuf[6] = 0x02;
                    com_tbuf[7] = 0x00;
                    com_tbuf[8] = 0x01;

                    crc = msrCRC(com_tbuf, 9);
                    com_tbuf[9] = (char)(crc >> 8);
                    com_tbuf[10] = (char)(crc & 0xff);
                    com_tlen = 11;
                    com_write(port);
                    msDelay(1000);

                    memset(com_rbuf, 0x00, sizeof(com_rbuf));
                    com_read(port);
                }
            }
        } //end of for
    }
}
/*** BeginHeader start_com_dev */
void start_com_dev(char port);
/*** EndHeader */
void start_com_dev(char port)
{
    char comPort;
    if ((port < 0) || (port > 6))  return;     //串口号错误

    if (ai_param[port + 8].model == 10000) return;

    if (modbusConfig[port].map485 == 1) comPort = 6;
    else comPort = port;

    if (ai_param[port + 8].model != 8014)
    {
        com_open(comPort, ai_param[comPort + 8].baudrate); //用指定的波特率打开串口
        com_databits(comPort, PARAM_8BIT);           //8个数据位，PARAM_7BIT
        com_parity(comPort, ai_param[comPort + 8].parity); //校验位，0,1,2,3
    }
    msDelay(20);

    switch (ai_param[port + 8].model)
    {
    case 2001:
        start_cod_hach(port);
        break;
    case 2010:
        start_cod_hongkai(port);
        break;
    case 2101: //哈希COMmax
        start_cod_zetian(port);
        break;
    case 2102: //哈希COMmax
        start_cod_zetian_ljg(port);
        break;
    case 3333:
        pack_modbus_cmd(modbusConfig[port].devAddr, modbusConfig[7].dataSort, modbusConfig[7].beginRegister, modbusConfig[7].registerCounter);
        com_write(comPort);
        break;
    case 4444:
        pack_modbus_cmd(modbusConfig[port].devAddr, modbusConfig[7].dataSort, modbusConfig[7].beginRegister, modbusConfig[7].registerCounter);
        com_write(comPort);
        break;
//此处添加不是modbus反控的仪表型号
    case 5555:
        break;
    case 6666:
        break;
    case 20101:
	start_cod_hongkai(port);    //鸿凯cod 新协议
	break;	
    case 9211:
	getSample_kengsheng_v2(port);    //科盛留样器
	break;	
    case 9994:
//	start_devicedriver_lihe(port);
        break;
    case 9995:
        start_device_nanjinghongkai(port);
        break;
    case 9996:
        start_device_htc_c(port);
        break;
    case 9997:
        start_device_wanyi(port);
        break;
	case 9998:
		start_device_songxia(port);
		break;
    default:
        break;
    }

    msDelay(100);
    if (ai_param[port + 8].model != 8014)
    {
        com_read(comPort);
        com_close(comPort);     //完成命令发送，关闭串口
        msDelay(10);         //延时50ms，等待串口底层驱动完全关闭
    }
}


/*** BeginHeader calib_metal_powermon */   //布朗卢比
void calib_metal_powermon(char port);
/*** EndHeader */
void calib_metal_powermon(char port)
{
    //0a 10 00 00 00 02 04 0f 00 00 00 d5 9f

    com_tbuf[0] = 0x0A;
    com_tbuf[1] = 0x10;
    com_tbuf[2] = 0x00;
    com_tbuf[3] = 0x00;
    com_tbuf[4] = 0x00;
    com_tbuf[5] = 0x02;
    com_tbuf[6] = 0x04;
    com_tbuf[7] = 0x0F;
    com_tbuf[8] = 0x00;
    com_tbuf[9] = 0x00;
    com_tbuf[10] = 0x00;
    com_tbuf[11] = 0xD5;
    com_tbuf[12] = 0x9F;
    com_tlen = 13;
    com_write(port);

    msDelay(10000);

    com_read(port);

    //0a 10 00 00 00 02 04 0f 00 02 00 d4 ff
    com_tbuf[0] = 0x0A;
    com_tbuf[1] = 0x10;
    com_tbuf[2] = 0x00;
    com_tbuf[3] = 0x00;
    com_tbuf[4] = 0x00;
    com_tbuf[5] = 0x02;
    com_tbuf[6] = 0x04;
    com_tbuf[7] = 0x0F;
    com_tbuf[8] = 0x00;
    com_tbuf[9] = 0x02;
    com_tbuf[10] = 0x00;
    com_tbuf[11] = 0xD4;
    com_tbuf[12] = 0xFF;
    com_tlen = 13;
    com_write(port);
}

/*** BeginHeader calib_com_dev */
char calib_com_dev(char port);
/*** EndHeader */
char calib_com_dev(char port)
{
    auto char c;
    c = 1;
    if ((port < 0) || (port > 6))  return 2;   //串口号错误
    DBG(printf("Calib COM%d\n", port);)
    com_open(port, ai_param[port+8].baudrate); //用指定的波特率打开串口
    com_databits(port, PARAM_8BIT);           //8个数据位，PARAM_7BIT
    com_parity(port, ai_param[port + 8].parity); //校验位，0,1,2,3
    msDelay(20);

    switch (ai_param[port + 8].model)
    {
    case 2013:
        calib_cod_ruiquan(port);
        break;
    case 9999: //test
        memset(com_tbuf, 0x00, sizeof(com_tbuf));
        strcpy(com_tbuf, "reset 0");
        com_tlen = strlen(com_tbuf);
        com_write(port);
        msDelay(150);
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (strcmp(com_rbuf, "error") == 0) c = 2;

        memset(com_tbuf, 0x00, sizeof(com_tbuf));
        strcpy(com_tbuf, "reset 1");
        com_tlen = strlen(com_tbuf);
        com_write(port);
        msDelay(150);
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (strcmp(com_rbuf, "error") == 0) c = 2;
        break;
    case 6008: //
        calib_metal_powermon(port);
        break;
    default:
        break;
    }

    msDelay(100);
    com_read(port);
    com_close(port);     //完成命令发送，关闭串口
    msDelay(10);         //延时50ms，等待串口底层驱动完全关闭
    return c;
}

/*** BeginHeader maintain_com_dev */
char maintain_com_dev(char port);
/*** EndHeader */
char maintain_com_dev(char port)
{
    auto char c;
    c = 1;
    if ((port < 0) || (port > 6))  return 2;   //串口号错误
    DBG(printf("Maintain COM%d\n", port);)
    com_open(port, ai_param[port+8].baudrate); //用指定的波特率打开串口
    com_databits(port, PARAM_8BIT);           //8个数据位，PARAM_7BIT
    com_parity(port, ai_param[port + 8].parity); //校验位，0,1,2,3
    msDelay(20);

    switch (ai_param[port + 8].model)
    {
    case 2013:
        maintain_cod_ruiquan(port);
        break;
    case 9999: //test
        memset(com_tbuf, 0x00, sizeof(com_tbuf));
        strcpy(com_tbuf, "get states");
        com_tlen = strlen(com_tbuf);
        com_write(port);
        msDelay(150);
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (strcmp(com_rbuf, "error") == 0) c = 2;
        break;
    default:
        break;
    }

    msDelay(100);
    com_read(port);
    com_close(port);     //完成命令发送，关闭串口
    msDelay(10);         //延时50ms，等待串口底层驱动完全关闭
    return c;
}

/*** BeginHeader setSmpTime_com_dev */
char setSmpTime_com_dev(char port);
/*** EndHeader */
char setSmpTime_com_dev(char port)
{
    auto char c;
    c = 1;
    if ((port < 0) || (port > 6))  return 2;   //串口号错误
    DBG(printf("Set cycle COM%d\n", port);)
    com_open(port, ai_param[port+8].baudrate); //用指定的波特率打开串口
    com_databits(port, PARAM_8BIT);           //8个数据位，PARAM_7BIT
    com_parity(port, ai_param[port + 8].parity); //校验位，0,1,2,3
    msDelay(20);

    switch (ai_param[port + 8].model)
    {
    case 9999: //test
        memset(com_tbuf, 0x00, sizeof(com_tbuf));
        strcpy(com_tbuf, "set cycle 100");
        com_tlen = strlen(com_tbuf);
        com_write(port);
        msDelay(150);
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (strcmp(com_rbuf, "error") == 0) c = 2;
        break;
    default:
        break;
    }

    msDelay(100);
    com_read(port);
    com_close(port);     //完成命令发送，关闭串口
    msDelay(10);         //延时50ms，等待串口底层驱动完全关闭
    return c;
}

/*** BeginHeader rd_test */
int rd_test(char port);
/*** EndHeader */
int rd_test(char port)
{
    static int status;
    costate
    {
        status = 0;
        waitfor(DelayMs(1000));
        memset(com_rbuf, '\0', sizeof(com_rbuf));
        com_read(port);
        if (com_rlen > 0)
        {
            com_f[0] = atof(com_rbuf);    //瞬时流量
            status = 1;
        }
        else
        {
            status = 2;
            com_f[0] = 0.0;
        }
        com_sec = read_rtc();         //采样时间
    }
    return status;
}

/*** BeginHeader start_test */
void start_test(char port);
/*** EndHeader */
void start_test(char port)
{
    strcpy(com_tbuf, "start sample");
    com_tlen = strlen(com_tbuf);
    com_write(port);
}

/*** BeginHeader ser232Task*/
void ser232Task(char port);
/*** EndHeader */
void ser232Task(char port)
{
    switch (port)
    {
    case 6:
        ser6write(deal_buf, (strlen(deal_buf)));
        break;
    default:
        ser0write(deal_buf, (strlen(deal_buf)));
        break;
    }
    //ser0write(deal_buf, (strlen(deal_buf)));
    //while (serAwrUsed() || BitRdPortI(SASR,2) || BitRdPortI(SASR,3));
}

/*** BeginHeader ser232ReadTask*/
void ser232ReadTask(char PORT_NUM, char no);
/*** EndHeader */
void ser232ReadTask(char PORT_NUM, char no)
{
//#define PORT_NUM	6
    costate
    {
        com_open(PORT_NUM, ai_param[PORT_NUM+8].baudrate); //用指定的波特率打开串口
        com_databits(PORT_NUM, PARAM_8BIT);           //8个数据位，PARAM_7BIT
        com_parity(PORT_NUM, ai_param[PORT_NUM + 8].parity); //校验位，0,1,2,3
        while (1)
        {
            memset(deal_buf, 0x00, sizeof(deal_buf));
            tcp_rlen[no] = 0;
            while (1)
            {
                memset(com_rbuf, 0x00, sizeof(com_rbuf));
                com_read(PORT_NUM);
                if (com_rlen > 0)
                {
                    if ((tcp_rlen[no] + com_rlen) >= 1024) break;
                    memcpy(&deal_buf[tcp_rlen[no]], com_rbuf, com_rlen);
                    tcp_rlen[no] += com_rlen;
                }
                else break;
            }

            if (tcp_rlen[no] > 0)
            {
                //memcpy(tcp_rbuf[2], deal_buf,tcp_rlen[2]);

                {
                    parsePackage(no);            //解析收到的数据包
                    if (err_flag[no] < 4)
                    {
                        parseCmd(no);            //命令预处理，调试时接受4以下的值，正常应只接受0或1
                    }
                    else                            //也许错误包不应响应
                    {
                        ack_flag[no] = 0;
                        packReqAck(no, 0);   //收到错误包，响应给服务器
                    }
                }
            }
            waitfor(DelaySec(1));

        }
    }
}



/*** BeginHeader chk_get_cod_water*/
int chk_get_cod_water(char port);
/*** EndHeader */
int chk_get_cod_water(char port)
{
    static unsigned char i;
    static int status;
    static float bakcodupval;
    auto int tmpcrc;
    static char pingnum, pingNo;
    static unsigned pingml;

    costate
    {
        status = 0;
        bakcodupval = 0;
        pingnum = 1;  //初始为1,1~24,第几号瓶,指定或者自动变化
        pingml = 500; //100ml ----指定
        pingNo = 2;  //设备仪器的modbus 设备地址 ----指定
        while (1)
        {
            waitfor(DelayMs(900));
            status = 1;
            for (i = 0; i < ALLADCHANNELS; i++)
            {
                if (Savech[i].polIndex == 5)
                {
                    if (ai_param[i].alarm_L > Savech[i].val ||
                        ai_param[i].alarm_H < Savech[i].val) //现超标.
                    {
                        if (ai_param[i].alarm_L <= bakcodupval &&
                            ai_param[i].alarm_H >= bakcodupval) //原来不超标
                        {
#ifdef DEBUG_PRINTF
                            printf("..................... \n");
#endif
                            com_open(port, ai_param[port + 8].baudrate); //用指定的波特率打开串口
                            com_databits(port, PARAM_8BIT);           //8个数据位，PARAM_7BIT
                            com_parity(port, ai_param[port + 8].parity); //校验位，0,1,2,3
                            msDelay(20);
                            com_tlen = 0;
                            com_tbuf[0] = 0x3a;
                            com_tbuf[1] = pingNo; //modbus地址
                            com_tbuf[2] = 0x03;   //功能码
                            com_tbuf[3] = pingnum; //x号瓶
                            com_tbuf[4] = (char)(pingml >> 8);    //数值H
                            com_tbuf[5] = (char)pingml;         //数值L
                            tmpcrc =  msrCRC(&com_tbuf[1], 5);
                            com_tbuf[6] = (char)(tmpcrc >> 8);
                            com_tbuf[7] = (char)tmpcrc;
                            com_tbuf[8] = 0x0d;
                            com_tbuf[9] = 0x0a;
                            com_tlen = 10;
                            pingnum++;
                            if (pingnum >= 25) pingnum = 1;

                            com_write(port);
                            msDelay(200);

                            com_read(port);
                            com_close(port);
                            msDelay(50);

                        }
                    }
                    if (((long)bakcodupval) != ((long)Savech[i].val)) //COD有变化时备份
                        bakcodupval = Savech[i].val;
                }
            }
        }
    }
    return status;
}

/*** BeginHeader checkCODAlarm*/
void checkCODAlarm(void);
/*** EndHeader */
void checkCODAlarm(void)
{
    costate
    {
        waitfor(chk_get_cod_water(5));
    }
}

/*** BeginHeader getSample_kesheng*/
int getSample_kesheng(char port);
/*** EndHeader */
/*******************************************************************************
科盛留样器
*******************************************************************************/
int getSample_kesheng(char port)
{
    static int status;
    auto int i;

    costate
    {
        status = 0;

        //超标留样指令  AA 34  30 30 35 30 30 30 31 BB  (留样500ml
        com_tbuf[0] = 0xAA;
        com_tbuf[1] = 0x34;
        com_tbuf[2] = 0x30;
        com_tbuf[3] = 0x30;
        com_tbuf[4] = 0x35;
        com_tbuf[5] = 0x30;
        com_tbuf[6] = 0x30;
        com_tbuf[7] = 0x30;
        com_tbuf[8] = 0x31;
        com_tbuf[9] = 0xBB;
        com_tlen = 10;
        com_write(port);

        waitfor(DelaySec(1));

        //成功收到指令，采样器返回：aa 34 00 bb
        //采样器正忙，返回：aa 34 01 bb
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);

        if (com_rlen > 0)
        {
#ifdef DEBUG_PRINTF
            for (i = 0; i < com_rlen; i++)
            {
                printf("%02X ", com_rbuf[i]);
            }
            printf(" \n");
#endif
        }
        else
        {
#ifdef DEBUG_PRINTF
            printf("no receive data \n");
#endif
        }

        if (com_rlen >= 4 && com_rbuf[0] == 0xCC && com_rbuf[1] == 0xDD)
        {
            if (com_rbuf[2] == 0xF1) //CC DD  F1 BB
            {
                waitfor(DelaySec(90));

#ifdef DEBUG_PRINTF
                printf("device busy \n");
#endif

                com_tbuf[0] = 0xAA;
                com_tbuf[1] = 0x34;
                com_tbuf[2] = 0x30;
                com_tbuf[3] = 0x30;
                com_tbuf[4] = 0x35;
                com_tbuf[5] = 0x30;
                com_tbuf[6] = 0x30;
                com_tbuf[7] = 0x30;
                com_tbuf[8] = 0x31;
                com_tbuf[9] = 0xBB;
                com_tlen = 10;
                com_write(port);

                waitfor(DelaySec(1));

                com_read(port);
            }
        }

        status = 1;
    }

    return status;
}

/*** BeginHeader getSample_kete*/
int getSample_kete(char port);
/*** EndHeader */
/*******************************************************************************
科盛留样器
*******************************************************************************/
int getSample_kete(char port)
{
    static int status;
    auto int i;

    costate
    {
        status = 0;

        //05H30H30H44H31H44H35H0DH
        com_tbuf[0] = 0x05;
        com_tbuf[1] = 0x30;
        com_tbuf[2] = 0x30;
        com_tbuf[3] = 0x44;
        com_tbuf[4] = 0x31;
        com_tbuf[5] = 0x44;
        com_tbuf[6] = 0x35;
        com_tbuf[7] = 0x0d;
        com_tlen = 8;
        com_write(port);

        waitfor(DelaySec(1));

        //成功收到指令，采样器返回：aa 34 00 bb
        //采样器正忙，返回：aa 34 01 bb
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);

        status = 1;
    }

    return status;
}

/*** BeginHeader enableBackupWater*/
int enableBackupWater(void);
/*** EndHeader */
int enableBackupWater(void)
{
#define  COM_PORT (5)   //控制留样器工作的串口

    static int status;

    costate
    {
        status = 0;

#ifdef DEBUG_PRINTF
        printf("enableBackupWater \n");
#endif

        com_open(COM_PORT, ai_param[COM_PORT + 8].baudrate); //用指定的波特率打开串口
        com_databits(COM_PORT, PARAM_8BIT);          //8个数据位，PARAM_7BIT
        com_parity(COM_PORT, ai_param[COM_PORT + 8].parity); //校验位，0,1,2,3
        msDelay(20);

        waitfor(getSample_kete(COM_PORT));

        com_close(COM_PORT);    //完成命令发送，关闭串口
        msDelay(10);         //延时50ms，等待串口底层驱动完全关闭

        status = 1;
    }

    return status;
}

/*** BeginHeader enableSmpTask*/
void enableSmpTask(void);
/*** EndHeader */
void enableSmpTask(void)
{
    costate
    {
        while (1)
        {
            if (enableSmpSign == 1)
            {
                waitfor(enableBackupWater());
                enableSmpSign = 0;
            }
            waitfor(DelaySec(1));
        }
    }
}

/*** BeginHeader modbus_06_float*/
void modbus_06_float(char port, unsigned addr, float value, char flag);
/*** EndHeader */
void modbus_06_float(char port, unsigned addr, float value, char flag)
{
    auto union uf f;
    auto unsigned tmpcrc;

    com_tbuf[0] = 0x64;
    com_tbuf[1] = 0x06;
    com_tbuf[2] = (char)(addr >> 4);
    com_tbuf[3] = (char)(addr & 0x0F);

    f.f = value;
    if (flag == 1)
    {
        com_tbuf[4] = f.ch[1];
        com_tbuf[5] = f.ch[0];
    }
    else
    {
        com_tbuf[4] = f.ch[3];
        com_tbuf[5] = f.ch[2];
    }

    tmpcrc =  msrCRC(&com_tbuf[0], 6);
    com_tbuf[6] = (char)(tmpcrc >> 8);
    com_tbuf[7] = (char)tmpcrc;

    com_tlen = 8;

    com_write(port);
}
/*** BeginHeader com_tasks*/
void com_tasks(void);
/*** EndHeader */
void com_tasks(void)
{
    costate
    {
        memset(com_rbuf,0x00,sizeof(com_rbuf));
        com_read(RS232_PORT);
        if (com_rlen > 20)
        {
            rs232_flag = 1;
            parsePackage(3);

            if (err_flag[3] < 4)
            {
                parseCmd(3);        //命令预处理，调试时接受4以下的值，正常应只接受0或1
            }
            else                    //也许错误包不应响应
            {
                ack_flag[3] = 0;
                packReqAck(3, 0);   //收到错误包，响应给服务器
            }
        }
        else
        {
            waitfor(DelaySec(3));
        }
    }

}
/*** BeginHeader writeDataToPLCTask*/
int writeDataToPLCTask(void);
/*** EndHeader */
int writeDataToPLCTask(void)
{
#define COM_PORT  6

    auto char ch;
    static float value;
    auto unsigned tmpcrc;
    static int status;
    costate
    {
        status = 0;
        com_open(COM_PORT, 9600L); //用指定的波特率打开串口
        msDelay(30);

        if ((getSampleChannel("011", &ch, 1, &value)) == 0)
        {
            value = 0.0;
        }
        modbus_06_float(COM_PORT, 8, value, 1);
        waitfor(DelaySec(1));
        com_read(COM_PORT);
        modbus_06_float(COM_PORT, 8, value, 0);
        waitfor(DelaySec(1));
        com_read(COM_PORT);

        if ((getSampleChannel("001", &ch, 1, &value)) == 0)
        {
            value = 0.0;
        }
        modbus_06_float(COM_PORT, 8, value, 1);
        waitfor(DelaySec(1));
        com_read(COM_PORT);
        modbus_06_float(COM_PORT, 8, value, 0);
        waitfor(DelaySec(1));
        com_read(COM_PORT);

        if ((getSampleChannel("060", &ch, 1, &value)) == 0)
        {
            value = 0.0;
        }
        modbus_06_float(COM_PORT, 8, value, 1);
        waitfor(DelaySec(1));
        com_read(COM_PORT);
        modbus_06_float(COM_PORT, 8, value, 0);
        waitfor(DelaySec(1));
        com_read(COM_PORT);

        if ((getSampleChannel("101", &ch, 1, &value)) == 0)
        {
            value = 0.0;
        }
        modbus_06_float(COM_PORT, 8, value, 1);
        waitfor(DelaySec(1));
        com_read(COM_PORT);
        modbus_06_float(COM_PORT, 8, value, 0);
        waitfor(DelaySec(1));
        com_read(COM_PORT);

        if ((getSampleChannel("065", &ch, 1, &value)) == 0)
        {
            value = 0.0;
        }
        modbus_06_float(COM_PORT, 8, value, 1);
        waitfor(DelaySec(1));
        com_read(COM_PORT);
        modbus_06_float(COM_PORT, 8, value, 0);
        waitfor(DelaySec(1));
        com_read(COM_PORT);

        if ((getSampleChannel("B01", &ch, 1, &value)) == 0)
        {
            value = 0.0;
        }
        modbus_06_float(COM_PORT, 8, value, 1);
        waitfor(DelaySec(1));
        com_read(COM_PORT);
        modbus_06_float(COM_PORT, 8, value, 0);
        waitfor(DelaySec(1));
        com_read(COM_PORT);


        com_close(COM_PORT);
        msDelay(50);
        status = 1;
    }
    return status;
}

/*** BeginHeader */
typedef enum
{
    send_synchronization_signal,
    send_alaram_signal,
    waitting_for_synchronization_signal
}work_order_t;
/*** EndHeader */

/*** BeginHeader reserved_sample*/
void reserved_sample(void);
/*** EndHeader */
void reserved_sample(void)
{
    auto char com_tbuf[255];
    auto int com_tlen;
    auto int reserved_ml;
    static unsigned long smp_alarm_inter_time;
    auto int i;
    auto alarm_count;
    static work_order_t work_order;
    auto struct tm time;

    costate
    {
        serFopen(ai_param[8].baudrate);
        serFwrFlush();
        serFrdFlush();
        smp_alarm_inter_time = SEC_TIMER; //留样间隔时间
        work_order = send_alaram_signal;
        while (1)
        {
            switch (work_order)
            {
            case send_synchronization_signal:
                mktm(&time, SEC_TIMER);
                //if(SEC_TIMER >= (smp_alarm_inter_time + (int)ai_param[8].alarm_H))
                if (time.tm_min <= 0x01)
                {
                    smp_alarm_inter_time = SEC_TIMER;
                    //同步命令AA 30 BB
                    com_tbuf[0] = 0xAA;
                    com_tbuf[1] = 0x30;
                    com_tbuf[2] = 0xBB;
                    com_tlen = 3;
                    serFwrite(com_tbuf, com_tlen);
                    waitfor(DelaySec(5));
                    work_order++;
                    printf("send synchronization\r\n");
                }
                break;
            case send_alaram_signal:
                alarm_count = 0;
                for (i = 0; i < ALLADCHANNELS; i++)
                {
                    if (Savech[i].flag == 'T')
                    {
                        alarm_count++;
                    }
                }

                if (alarm_count > 0)
                {
                    reserved_ml = (int)ai_param[8].alarm_L;
                    memset(com_tbuf, 0x00, sizeof(com_tbuf));
                    com_tbuf[0] = 0xAA;
                    com_tbuf[1] = 0x34;
                    com_tbuf[2] = 0x30;
                    com_tbuf[3] = 0x30;
                    com_tbuf[4] = 0x32;
                    com_tbuf[5] = 0x30;
                    com_tbuf[6] = 0x30;
                    com_tbuf[7] = 0x30;
                    com_tbuf[8] = 0x31;
                    com_tbuf[9] = 0xBB;
                    com_tlen = 10;
                    serFwrite(com_tbuf, com_tlen);
                    printf("reserved_sample ok\r\n");
                    smp_alarm_inter_time = SEC_TIMER; //留样间隔时间
                    digOut(0, 1);
                    waitfor(DelaySec(5));
                    digOut(0, 0);
                    work_order = waitting_for_synchronization_signal;
                }
                break;
            case waitting_for_synchronization_signal:
                if (SEC_TIMER >= (smp_alarm_inter_time + (int)ai_param[8].alarm_H))
                {
                    work_order = send_alaram_signal;
                    printf("synchronization time now\r\n");
                }
                break;
            default:
                work_order = send_alaram_signal;
                break;
            }

            /*if(SEC_TIMER >= (smp_alarm_inter_time + (int)ai_param[8].alarm_H))
               {
               alarm_count=0;
               for(i=0;i<ALLADCHANNELS;i++)
               {
               if(Savech[i].flag=='T')
               {
               alarm_count++;
               }
               }
               if(alarm_count>0)
               {
               reserved_ml = (int)ai_param[8].alarm_L;
               memset(com_tbuf,0x00,sizeof(com_tbuf));
               com_tbuf[0] = 0xAA;
               com_tbuf[1] = 0x34;
               com_tbuf[2] = 0x30+((reserved_ml/10000)%10);
               com_tbuf[3] = 0x30+((reserved_ml/1000)%10);
               com_tbuf[4] = 0x30+((reserved_ml/100)%10);
               com_tbuf[5] = 0x30+((reserved_ml/10)%10);
               com_tbuf[6] = 0x30+(reserved_ml%10);
               com_tbuf[7] = 0x30;
               com_tbuf[8] = 0x31;
               com_tbuf[9] = 0xBB;
               com_tlen=10;
               serFwrite(com_tbuf,com_tlen);
               printf("reserved_sample ok");
               }
               smp_alarm_inter_time = SEC_TIMER;//留样间隔时间
               }*/
            waitfor(DelayMs(1000));
        }
    }
}

/*** BeginHeader modbusTcp_poll*/
int modbusTcp_poll(char port, char comNo);
/*** EndHeader */
int modbusTcp_poll(char port, char comNo)
{
    static int status;
    auto char index;
    auto union uf f;
    auto char i;
    costate
    {
        status = 0;
        memset(com_tbuf, 0x00, sizeof(com_tbuf));
        index = 5;
        com_tbuf[index++] = 6;
        com_tbuf[index++] = modbusConfig[comNo].devAddr;
        com_tbuf[index++] = 0x03;
        com_tbuf[index++] = modbusConfig[comNo].beginRegister / 256;
        com_tbuf[index++] = modbusConfig[comNo].beginRegister % 256;
        com_tbuf[index++] = modbusConfig[comNo].registerCounter / 256;
        com_tbuf[index++] = modbusConfig[comNo].registerCounter % 256;
        com_tlen = index;
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= modbusConfig[comNo].registerCounter * 2 + 3 + 5) && (com_rbuf[6] == modbusConfig[comNo].devAddr) && (com_rbuf[7] == 0x03))
        {

            for (i = 0; i < modbusConfig[comNo].registerCounter / 2; i++)
            {
                if (modbusConfig[comNo].dataSort == DT_FLOAT)
                {
                    f.ch[1] = com_rbuf[9 + i * 4];
                    f.ch[0] = com_rbuf[10 + i * 4];
                    f.ch[3] = com_rbuf[11 + i * 4];
                    f.ch[2] = com_rbuf[12 + i * 4];
                    com_f[i] = f.f;
                }
                else if (modbusConfig[comNo].dataSort == DT_FLOAT_INVERSE)
                {
                    f.ch[3] = com_rbuf[9 + i * 4];
                    f.ch[2] = com_rbuf[10 + i * 4];
                    f.ch[1] = com_rbuf[11 + i * 4];
                    f.ch[0] = com_rbuf[12 + i * 4];
                    com_f[i] = f.f;
                }
                else if (modbusConfig[comNo].dataSort == DT_FLOAT_0123)
                {
                    f.ch[0] = com_rbuf[9 + i * 4];
                    f.ch[1] = com_rbuf[10 + i * 4];
                    f.ch[2] = com_rbuf[11 + i * 4];
                    f.ch[3] = com_rbuf[12 + i * 4];
                    com_f[i] = f.f;
                }
                else
                {
                    f.ch[2] = com_rbuf[9 + i * 4];
                    f.ch[3] = com_rbuf[10 + i * 4];
                    f.ch[0] = com_rbuf[11 + i * 4];
                    f.ch[1] = com_rbuf[12 + i * 4];
                    com_f[i] = f.f;
                }
                status = 1;
            }
        }
        else
        {
            for (i = 0; i < modbusConfig[comNo].registerCounter / 2; i++)
            {
                com_f[i] = 0.0;
            }
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}

/*** BeginHeader com_8014_pack_task*/
void com_8014_pack_task(char port);
/*** EndHeader */
void com_8014_pack_task(char port)
{
    auto char p;
    auto char ch;
    auto char c;
    auto char no;
    auto char flag;
    auto float f;
    auto int data_tlen;

    costate
    {
        com_open(port, ai_param[port + 8].baudrate); //用指定的波特率打开串口
        com_databits(port, PARAM_8BIT);           //8个数据位，PARAM_7BIT
        com_parity(port, ai_param[port + 8].parity); //校验位，0,1,2,3
        msDelay(20);
        while (1)
        {
            no = 0;
            t0 = read_rtc();
            mktm(&rtc1, t0);
            calQn(no);
            flag = getFlag(no);

            memset(deal_buf, 0x00, sizeof(deal_buf));
            memset(pol_pack_buf, 0x00, sizeof(pol_pack_buf));
            if (modbusConfig[port].devAddr !=  1)
            {
                sprintf(deal_buf, "##0000QN=%s;ST=%d;CN=2011;PW=%s;MN=%s;Flag=%d;CP=&&",
                        qn[no], systemCode, sipPwd[no], MNParam.MN[no], flag);
            }
            else
            {
                sprintf(deal_buf, "##0000ST=%d;CN=2011;PW=%s;MN=%s;Flag=%d;CP=&&",
                        systemCode, sipPwd[no], MNParam.MN[no], flag);
            }

            sprintf(pol_pack_buf, "DataTime=%04d%02d%02d%02d%02d%02d;",
                    rtc1.tm_year + 1900, rtc1.tm_mon, rtc1.tm_mday,
                    rtc1.tm_hour, rtc1.tm_min, rtc1.tm_sec);
            strcat(deal_buf, pol_pack_buf);


            for (c = 0; c < ALLADCHANNELS; c++)   //统计
            {
                if ((Savech[c].polIndex >= 0) && (Savech[c].polIndex < BOCON_NO_OF_POL))
                {
                    p = Savech[c].polIndex;
                    if ((getSampleChannel(PolCode[p], &ch, 1, &f) == 1))
                    {
                        memset(pol_pack_buf, 0x00, sizeof(pol_pack_buf));
                        sprintf(pol_pack_buf, "%s-Rtd=%.3f,%s-Flag=%c;",
                                PolCode[p], Savech[ch].val,
                                PolCode[p], Savech[ch].flag);
                        strcat(deal_buf, pol_pack_buf);
                    }
                }
            }

            strcpy(&(deal_buf[strlen(deal_buf) - 1]), "&&");
            data_tlen = strlen(deal_buf) - 6;
            tcp_tlen[no] = data_tlen + 12;
            CRC16(&deal_buf[6], data_tlen);
            deal_buf[data_tlen + 6] = crc[0];
            deal_buf[data_tlen + 7] = crc[1];
            deal_buf[data_tlen + 8] = crc[2];
            deal_buf[data_tlen + 9] = crc[3];
            deal_buf[data_tlen + 10] = 0x0d;
            deal_buf[data_tlen + 11] = 0x0a;
            deal_buf[2] = data_tlen / 1000 + 0x30;
            data_tlen %= 1000;
            deal_buf[3] = data_tlen / 100 + 0x30;
            data_tlen %= 100;
            deal_buf[4] = data_tlen / 10 + 0x30;
            data_tlen %= 10;
            deal_buf[5] = data_tlen + 0x30;
            data_tlen = strlen(deal_buf);
            ser232Task(port);
            waitfor(DelayMs(3000));
        }
    }
}

/*** BeginHeader polcode_ctrl_realy_task*/
void polcode_ctrl_realy_task(void);
/*** EndHeader */
void polcode_ctrl_realy_task(void)
{
#define TIME_DELAY	600		//10分钟
    auto char ch;
    auto char index;
    auto float B01;
    static char CONTROL_STATUS;
    static unsigned long Time1;
    static unsigned long Time2;

    costate
    {
        CONTROL_STATUS=0;
        Time1 = 0;
        Time2 = 0;
        while (1)
        {
            if (modbusConfig[7].devAddr >= BOCON_NO_OF_POL / 2) index = 0;
            else index = modbusConfig[7].devAddr;
            if (getSampleChannel(PolCode[index], &ch, 1, &B01))
            {
                switch (CONTROL_STATUS)
                {
                case 0:
                    if ((B01 > 0) && (CONTROL_STATUS == 0))
                    {
                        CONTROL_STATUS++;
                        Time1 = SEC_TIMER;
                    }
                    break;
                case 1:
                    if (SEC_TIMER >= (Time1 + TIME_DELAY))       //延时10分钟后闭合继电器
                    {
                        digOut(0, 1);
                        CONTROL_STATUS++;
                        Time2 = SEC_TIMER;
                    }
                    break;
                case 2:
                    if (SEC_TIMER >= (Time2 + TIME_DELAY))        //延时10分钟后断开电器
                    {
                        digOut(0, 0);
                        CONTROL_STATUS = 0;
                        Time1 = 0;
                        Time2 = 0;
                    }
                    break;
                }
            }
            else
            {
                digOut(0, 0);
                CONTROL_STATUS = 0;
                Time1 = 0;
                Time2 = 0;
            }
            waitfor(DelayMs(2000));
        }
    }
}

/*** BeginHeader com_tcp_rec_pack_task*/
void com_tcp_rec_pack_task(char port, char *buf, int len);
/*** EndHeader */
void com_tcp_rec_pack_task(char port, char *buf, int len)
{
    costate
    {
        if (ai_param[port + 8].polIndex >= BOCON_NO_OF_POL)
        {
            com_open(port, ai_param[port + 8].baudrate); //用指定的波特率打开串口
            com_databits(port, PARAM_8BIT);           //8个数据位，PARAM_7BIT
            com_parity(port, ai_param[port + 8].parity); //校验位，0,1,2,3
            msDelay(20);
            while (1)
            {
                switch (port)
                {
                case 0:
                    ser0write(buf, len);
                    break;
                case 1:
                    ser1write(buf, len);
                    break;
                case 2:
                case 3:
                case 4:
                case 5:
                    ser2write(buf, len);
                    break;
                default:
                    ser6write(buf, len);
                    break;
                }
                waitfor(DelayMs(10));
            }
        }
        waitfor(DelayMs(10));
    }
}


/*** BeginHeader save_value_clean_zero_task*/
void save_value_clean_zero_task(void);
/*** EndHeader */
void save_value_clean_zero_task(void)
{
    auto int i;
    auto char p;
    costate
    {
        while (1)
        {
            for (i = 0; i < ALLADCHANNELS; i++)
            {
                p = Savech[i].polIndex;
                if ((p >= 0) && (p < BOCON_NO_OF_POL))
                {
                    if (SEC_TIMER > Savech[i].time + 300)
                    {
                        Savech[i].val = 0.0;
                        Savech[i].flag = 'D';
                    }
                }
            }
            waitfor(DelayMs(1000));
        }
    }
}


/*** BeginHeader disp_flag_status_task*/
void disp_flag_status_task(void);
/*** EndHeader */
void disp_flag_status_task(void)
{
    auto char tmp;
    static char flag;
    costate
    {
        while (1)
        {
            for (tmp = 0; tmp < ALLADCHANNELS; tmp++)
            {
                if ((Savech[tmp].polIndex >= 0) && (Savech[tmp].polIndex < BOCON_NO_OF_POL))
                {
                    switch (workmode[0])
                    {
                    case 0:
                        if (flag != 0)
                        {
                            flag = 0;
                            Savech[tmp].flag = 'D';
                        }
                        break;
                    case 1:
                        Savech[tmp].flag = 'F';
                        break;
                    case 2:
                        Savech[tmp].flag = 'M';
                        break;
                    case 3:
                        Savech[tmp].flag = 'S';
                        break;
                    case 4:
                        Savech[tmp].flag = 'C';
                        break;
                    case 5:
                        Savech[tmp].flag = 'B';
                        break;
                    default:
                        break;
                    }
                    if (workmode[0] != 0)
                    {
                        flag = 1;
                    }
                }
            }
            waitfor(DelayMs(100));
        }
    }
}

#define _______________ADD_______________

/*** BeginHeader rd_S02_weichuang*/
int rd_S02_weichuang(char port);
/*** EndHeader */
int rd_S02_weichuang(char port)
{ //计算标态流量
    auto char ch;
    auto float f1, f2;
    auto float Kp, Ts, Pd, Ms, Ba, Ps;

    Kp = 0.84;
    Ms = 28.96;
    Ba = 101325;

    if ((getSampleChannel("S03", &ch, 1, &Ts) == 1) &&
        (getSampleChannel("S04", &ch, 1, &Pd) == 1) &&
        (getSampleChannel("S08", &ch, 1, &Ps) == 1))
    {
        f1 = (273.15 + Ts) * Pd;
        f2 = Ms * (Ba + Ps);
        if (f2 > 0.0)
        {
            f2 = f1 / f2;
            if (f2 > 0.0)
            {
                com_f[0] = pow(f2, 0.5);
                com_f[0] = 128.9 * Kp * com_f[0];
            }
            else
            {
                com_f[0] = 0.0;
            }
        }
        else
        {
            com_f[0] = 0.0;
        }
    }
    else
    {
        com_f[0] = 0.0;
    }
    com_sec = read_rtc();

    return 1;
}

/*** BeginHeader rd_device_guizhouchegnda*/
int rd_device_guizhouchegnda(char port);
/*** EndHeader */
int rd_device_guizhouchegnda(char port)
{
    static int status;
    auto union uf f;

    costate
    {
        status = 0;
        pack_modbus_cmd(0x01, 0x03, 0x00, 0x02);
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x01) && (com_rbuf[1] == 0x03))
        {
            f.ch[1] = com_rbuf[3];
            f.ch[0] = com_rbuf[4];
            f.ch[3] = com_rbuf[5];
            f.ch[2] = com_rbuf[6];
            com_f[0] = f.f;         //即时值
        }
        else
        {
            com_f[0] = 0.0;
        }
        pack_modbus_cmd(0x03, 0x03, 0x00, 0x02);
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x03) && (com_rbuf[1] == 0x03))
        {
            f.ch[1] = com_rbuf[3];
            f.ch[0] = com_rbuf[4];
            f.ch[3] = com_rbuf[5];
            f.ch[2] = com_rbuf[6];
            com_f[1] = f.f;         //即时值
        }
        else
        {
            com_f[1] = 0.0;
        }
        pack_modbus_cmd(0x04, 0x03, 0x00, 0x02);
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x04) && (com_rbuf[1] == 0x03))
        {
            f.ch[1] = com_rbuf[3];
            f.ch[0] = com_rbuf[4];
            f.ch[3] = com_rbuf[5];
            f.ch[2] = com_rbuf[6];
            com_f[2] = f.f;         //即时值
        }
        else
        {
            com_f[2] = 0.0;
        }
        pack_modbus_cmd(0x05, 0x03, 0x00, 0x02);
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x05) && (com_rbuf[1] == 0x03))
        {
            f.ch[1] = com_rbuf[3];
            f.ch[0] = com_rbuf[4];
            f.ch[3] = com_rbuf[5];
            f.ch[2] = com_rbuf[6];
            com_f[3] = f.f;         //即时值
        }
        else
        {
            com_f[3] = 0.0;
        }
        pack_modbus_cmd(0x06, 0x03, 0x00, 0x02);
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x06) && (com_rbuf[1] == 0x03))
        {
            f.ch[1] = com_rbuf[3];
            f.ch[0] = com_rbuf[4];
            f.ch[3] = com_rbuf[5];
            f.ch[2] = com_rbuf[6];
            com_f[4] = f.f;         //即时值
        }
        else
        {
            com_f[4] = 0.0;
        }
        pack_modbus_cmd(0x02, 0x03, 0x00, 0x02);
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x02) && (com_rbuf[1] == 0x03))
        {
            f.ch[1] = com_rbuf[3];
            f.ch[0] = com_rbuf[4];
            f.ch[3] = com_rbuf[5];
            f.ch[2] = com_rbuf[6];
            com_f[5] = f.f;         //即时值
        }
        else
        {
            com_f[5] = 0.0;
        }
        status = 1;
        com_sec = read_rtc();
    }
    return status;

}

#define _______________SUZHOUWEISHUI_______________

/*******************************************************************************
主机发送：0E 03 00 2F 00 02 F5 3D
仪器返回：0E 03 04 3E B0 A3 D7 31 92
其中0E代表地址，通过屏幕485设置里可以设置，注意0E对应屏幕的14（十六进制和十进制的换算）；
主机发送指令详细说明：
03：代表读取指令；
002F:代表读取的地址，002F是数值的地址；
0002:代表读取2个16位，即32位数据，数值是浮点型占有32位；
F53D:是CRC校验
仪器返回详细说明：
0E:代表地址
03:功能码
04:代表返回4个字节
3E B0 A3 D7:代表一个浮点型，0.345
31 92:CRC校验码
*******************************************************************************/
/*** BeginHeader rd_device_weishui*/
int rd_device_weishui(char port);
/*** EndHeader */
int rd_device_weishui(char port)
{
    static int status;
    auto struct tm rtc;
    auto union uf f; //uf这在K36的驱动库里已定义

    costate
    {
        status = 0;

        pack_modbus_cmd(0x01, 0x03, 0x02, 0x04);
        com_write(port);
        waitfor(DelayMs(1000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 10) && (com_rbuf[0] == 0x01) && (com_rbuf[1] == 0x03))
        {
            f.ch[3] = com_rbuf[3];
            f.ch[2] = com_rbuf[4];
            f.ch[1] = com_rbuf[5];
            f.ch[0] = com_rbuf[6];
            com_f[0] = (float)f.l;
            com_f[0] /= 10.0;                 //瞬时流量，单位m3/h
                                              //com_f[0] /= 3.6;			//采集单位m3/h,显示单位L/s

            f.ch[3] = com_rbuf[7];
            f.ch[2] = com_rbuf[8];
            f.ch[1] = com_rbuf[9];
            f.ch[0] = com_rbuf[10];
            com_f[1] = (float)f.l;       //累计流量,m3

        }
        else
        {
            com_f[0] = 0.0;
            com_f[1] = 0.0;
        }

        pack_modbus_cmd(0x0E, 0x03, 0x2F, 0x02);
        com_write(port);
        waitfor(DelayMs(1000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x0E) && (com_rbuf[1] == 0x03))
        {
            f.ch[3] = com_rbuf[3];
            f.ch[2] = com_rbuf[4];
            f.ch[1] = com_rbuf[5];
            f.ch[0] = com_rbuf[6];
            com_f[2] = f.f;
        }
        else
        {
            com_f[2] = 0.0;
        }

        pack_modbus_cmd(0x0F, 0x03, 0x2F, 0x02);
        com_write(port);
        waitfor(DelayMs(1000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x0F) && (com_rbuf[1] == 0x03))
        {
            f.ch[3] = com_rbuf[3];
            f.ch[2] = com_rbuf[4];
            f.ch[1] = com_rbuf[5];
            f.ch[0] = com_rbuf[6];
            com_f[3] = f.f / 1000.0;
        }
        else
        {
            com_f[3] = 0.0;
        }

        pack_modbus_cmd(0x10, 0x03, 0x2F, 0x02);
        com_write(port);
        waitfor(DelayMs(1000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x10) && (com_rbuf[1] == 0x03))
        {
            f.ch[3] = com_rbuf[3];
            f.ch[2] = com_rbuf[4];
            f.ch[1] = com_rbuf[5];
            f.ch[0] = com_rbuf[6];
            com_f[4] = f.f;
        }
        else
        {
            com_f[4] = 0.0;
        }

        pack_modbus_cmd(0x11, 0x03, 0x2F, 0x02);
        com_write(port);
        waitfor(DelayMs(1000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x11) && (com_rbuf[1] == 0x03))
        {
            f.ch[3] = com_rbuf[3];
            f.ch[2] = com_rbuf[4];
            f.ch[1] = com_rbuf[5];
            f.ch[0] = com_rbuf[6];
            com_f[5] = f.f / 1000.0;
        }
        else
        {
            com_f[5] = 0.0;
        }

        status = 1;
        com_sec = read_rtc();
    }
    return status;
}

/*** BeginHeader rd_device_weishui_v2*/
int rd_device_weishui_v2(char port);
/*** EndHeader */
int rd_device_weishui_v2(char port)
{
    static int status;
    auto struct tm rtc;
    auto union uf f; //uf这在K36的驱动库里已定义

    costate
    {
        status = 0;

        pack_modbus_cmd(14, 0x03, 34, 0x02);
        com_write(port);
        waitfor(DelaySec(60));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 14) && (com_rbuf[1] == 0x03))
        {
            f.ch[3] = com_rbuf[3];
            f.ch[2] = com_rbuf[4];
            f.ch[1] = com_rbuf[5];
            f.ch[0] = com_rbuf[6];
            com_f[0] = f.f;
        }
        else
        {
            com_f[0] = 0.0;
        }

        pack_modbus_cmd(14, 0x03, 38, 0x02);
        com_write(port);
        waitfor(DelayMs(2000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 14) && (com_rbuf[1] == 0x03))
        {
            f.ch[3] = com_rbuf[3];
            f.ch[2] = com_rbuf[4];
            f.ch[1] = com_rbuf[5];
            f.ch[0] = com_rbuf[6];
            com_f[1] = f.f;
        }
        else
        {
            com_f[1] = 0.0;
        }

        status = 1;
        com_sec = read_rtc();
    }
    return status;
}

/*** BeginHeader rd_device_weishui_v3*/
int rd_device_weishui_v3(char port);
/*** EndHeader */
int rd_device_weishui_v3(char port)
{
    static int status;
    auto struct tm rtc;
    auto union uf f; //uf这在K36的驱动库里已定义

    costate
    {
        status = 0;

        pack_modbus_cmd(0x0E, 0x03, 0x2F, 0x02);
        com_write(port);
        waitfor(DelayMs(1000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x0E) && (com_rbuf[1] == 0x03))
        {
            f.ch[3] = com_rbuf[3];
            f.ch[2] = com_rbuf[4];
            f.ch[1] = com_rbuf[5];
            f.ch[0] = com_rbuf[6];
            com_f[0] = f.f;
        }
        else
        {
            com_f[0] = 0.0;
        }

        pack_modbus_cmd(0x0F, 0x03, 0x2F, 0x02);
        com_write(port);
        waitfor(DelayMs(1000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x0F) && (com_rbuf[1] == 0x03))
        {
            f.ch[3] = com_rbuf[3];
            f.ch[2] = com_rbuf[4];
            f.ch[1] = com_rbuf[5];
            f.ch[0] = com_rbuf[6];
            com_f[1] = f.f / 1000.0;
        }
        else
        {
            com_f[1] = 0.0;
        }

        pack_modbus_cmd(0x10, 0x03, 0x2F, 0x02);
        com_write(port);
        waitfor(DelayMs(1000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x10) && (com_rbuf[1] == 0x03))
        {
            f.ch[3] = com_rbuf[3];
            f.ch[2] = com_rbuf[4];
            f.ch[1] = com_rbuf[5];
            f.ch[0] = com_rbuf[6];
            com_f[2] = f.f;
        }
        else
        {
            com_f[2] = 0.0;
        }

        pack_modbus_cmd(0x11, 0x03, 0x2F, 0x02);
        com_write(port);
        waitfor(DelayMs(1000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x11) && (com_rbuf[1] == 0x03))
        {
            f.ch[3] = com_rbuf[3];
            f.ch[2] = com_rbuf[4];
            f.ch[1] = com_rbuf[5];
            f.ch[0] = com_rbuf[6];
            com_f[3] = f.f / 1000.0;
        }
        else
        {
            com_f[3] = 0.0;
        }

        status = 1;
        com_sec = read_rtc();
    }
    return status;
}

/*** BeginHeader rd_device_weishui_v4*/
int rd_device_weishui_v4(char port, char addr);
/*** EndHeader */
int rd_device_weishui_v4(char port, char addr)
{
    static int status;
    auto struct tm rtc;
    auto union uf f, data; //uf这在K36的驱动库里已定义

    costate
    {
        status = 0;

        memset(com_tbuf, 0x00, sizeof(com_tbuf));
        pack_modbus_cmd(addr, 0x04, 0x1010, 0x02);
        com_write(port);
        waitfor(DelaySec(1));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (com_rlen > 8 && com_rbuf[0] == addr && com_rbuf[1] == 0x04)
        {
            data.ch[0] = com_rbuf[6];
            data.ch[1] = com_rbuf[5];
            data.ch[2] = com_rbuf[4];
            data.ch[3] = com_rbuf[3];
            com_f[0] = data.f;

            memset(com_tbuf, 0x00, sizeof(com_tbuf));
            pack_modbus_cmd(addr, 0x04, 0x1020, 0x01);
            com_write(port);
            waitfor(DelaySec(1));
            memset(com_rbuf, 0x00, sizeof(com_rbuf));
            com_read(port);
            if (com_rlen > 6 && com_rbuf[0] == addr && com_rbuf[1] == 0x04)
            {
                if (com_rbuf[4] == 0x05)
                {
                    com_f[0] = com_f[0] / 3.6;
                }
            }

            memset(com_tbuf, 0x00, sizeof(com_tbuf));
            pack_modbus_cmd(addr, 0x04, 0x1018, 0x02);
            com_write(port);
            waitfor(DelaySec(1));
            memset(com_rbuf, 0x00, sizeof(com_rbuf));
            com_read(port);
            if (com_rlen > 6 && com_rbuf[0] == addr && com_rbuf[1] == 0x04)
            {
                data.ch[0] = com_rbuf[6];
                data.ch[1] = com_rbuf[5];
                data.ch[2] = com_rbuf[4];
                data.ch[3] = com_rbuf[3];
                com_f[1] = data.l;
            }
        }
        else
        {
            com_f[0] = 0.0;
            com_f[1] = 0.0;
        }

        pack_modbus_cmd(0x0E, 0x03, 0x2F, 0x02);
        com_write(port);
        waitfor(DelayMs(1000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x0E) && (com_rbuf[1] == 0x03))
        {
            f.ch[3] = com_rbuf[3];
            f.ch[2] = com_rbuf[4];
            f.ch[1] = com_rbuf[5];
            f.ch[0] = com_rbuf[6];
            com_f[2] = f.f;
        }
        else
        {
            com_f[2] = 0.0;
        }

        pack_modbus_cmd(0x0F, 0x03, 0x2F, 0x02);
        com_write(port);
        waitfor(DelayMs(1000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x0F) && (com_rbuf[1] == 0x03))
        {
            f.ch[3] = com_rbuf[3];
            f.ch[2] = com_rbuf[4];
            f.ch[1] = com_rbuf[5];
            f.ch[0] = com_rbuf[6];
            com_f[3] = f.f / 1000.0;
        }
        else
        {
            com_f[3] = 0.0;
        }

        pack_modbus_cmd(0x10, 0x03, 0x2F, 0x02);
        com_write(port);
        waitfor(DelayMs(1000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x10) && (com_rbuf[1] == 0x03))
        {
            f.ch[3] = com_rbuf[3];
            f.ch[2] = com_rbuf[4];
            f.ch[1] = com_rbuf[5];
            f.ch[0] = com_rbuf[6];
            com_f[4] = f.f;
        }
        else
        {
            com_f[4] = 0.0;
        }

        pack_modbus_cmd(0x11, 0x03, 0x2F, 0x02);
        com_write(port);
        waitfor(DelayMs(1000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x11) && (com_rbuf[1] == 0x03))
        {
            f.ch[3] = com_rbuf[3];
            f.ch[2] = com_rbuf[4];
            f.ch[1] = com_rbuf[5];
            f.ch[0] = com_rbuf[6];
            com_f[5] = f.f / 1000.0;
        }
        else
        {
            com_f[5] = 0.0;
        }

        status = 1;
        com_sec = read_rtc();
    }
    return status;
}

#define _______________SUZHOUWEISHUI_______________

//杭州海驰，氨氮计算
/*** BeginHeader rd_andan_count */
int  rd_andan_count(void);
/*** EndHeader */
int  rd_andan_count(void)
{
    static int status;
    auto float no1, no2, nox;
    auto char ch;
    costate
    {
        status = 0;
//      waitfor(DelaySec(2));
        if (getSampleChannel("NO1", &ch, 1, &no1) == 1)
        {
            no1 = Savech[ch].val;
        }
        else no1 = 0;
        if (getSampleChannel("NO2", &ch, 1, &no2) == 1)
        {
            no2 = Savech[ch].val;
        }
        else no2 = 0;
        com_f[0] = no1 + no2;

        status = 1;
        com_sec = read_rtc();
    }
    return status;
}


/*** BeginHeader rd_cod_analog_v3*/
int rd_cod_analog_v3(char port, char address, char vata_port);
/*** EndHeader */
int rd_cod_analog_v3(char port, char address, char vata_port)
{
#define	EXTEND_PARAM_COUNT	(20)//串口扩展参数有多少个
    static int status;
    auto union uf f; //uf这在K36的驱动库里已定义
    static char ch, i;
    auto char j;
    auto CHARTOINTTY data;
    auto float maxSignalValue, minSignalValue;

    costate
    {
        status = 0;

        pack_modbus_cmd(address, 0x03, 0, 10);
        com_write(port);

        waitfor(DelaySec(2));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (com_rlen > 0 && com_rbuf[0] == address && com_rbuf[1] == 0x03)
        {
            maxSignalValue = 10000;
            minSignalValue = 0;
            for (i = 0; i < 4; i++)
            {
                if (i == 0)
                {
                    f.ch[1] = com_rbuf[3];
                    f.ch[0] = com_rbuf[4];
                    com_f[0] = f.i[0];          //即时值
                    if (com_f[0] < minSignalValue)
                    {
                        com_f[0] = 0.0;
                    }
                    else if (com_f[0] > maxSignalValue)
                    {
                        com_f[0] = ai_param[vata_port + 8].alarm_H;
                    } //|| com_f[0] > 20.0)
                    else
                    {
//         			com_f[0] = ((ai_param[vata_port+8].alarm_H - ai_param[vata_port+8].alarm_L) / (maxSignalValue-minSignalValue))
//                           * (com_f[0] - minSignalValue) + ai_param[vata_port+8].alarm_L;

                        com_f[0] = ((com_f[0] / 500) - 4) * ((ai_param[vata_port + 8].alarm_H - ai_param[vata_port + 8].alarm_L) / (20 - 4));
                    }

                    printf("com_f[0] = %f\r\n", com_f[0]);
                }
                else
                {
                    for (ch = 0; ch < EXTEND_PARAM_COUNT; ch++)
                    {
                        if (ai_param_extend[ch].polIndex >= BOCON_NO_OF_POL) continue; //判断这通道有没有使用
                        if (ai_param_extend[ch].port != vata_port) continue; //判断是否是对应的串口
                        if (ai_param_extend[ch].position != i) continue; //位置是否对应

                        j = i * 4 + 3;
//                  j = i*2+3;
                        f.ch[1] = com_rbuf[j];
                        f.ch[0] = com_rbuf[j + 1];
                        com_f[ai_param_extend[ch].position] = f.i[0];           //即时值

                        if (com_f[ai_param_extend[ch].position] < minSignalValue)
                        {
                            com_f[ai_param_extend[ch].position] = 0;
                        }
                        else if (com_f[ai_param_extend[ch].position] > maxSignalValue)
                        {
                            com_f[ai_param_extend[ch].position] = ai_param_extend[ch].alarm_H;
                        }
                        else
                        {
//     				com_f[ai_param_extend[ch].position] = ((ai_param_extend[ch].alarm_H - ai_param_extend[ch].alarm_L) / (maxSignalValue-minSignalValue))
//                                                      * (com_f[ai_param_extend[ch].position] - minSignalValue) + ai_param_extend[ch].alarm_L;
                            com_f[ai_param_extend[ch].position] = ((com_f[ai_param_extend[ch].position] / 500) - 4) * ((ai_param_extend[ch].alarm_H - ai_param_extend[ch].alarm_L) / (20 - 4));
                        }
                        printf("com_f[%d] = %f\r\n", ai_param_extend[ch].position, com_f[ai_param_extend[ch].position]);
                        break;
                    }
                }
            }
            status = 1;
        }
        else
        {
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}



/*** BeginHeader calcrc*/
int calcrc(char *ptr, int count);
/*** EndHeader */
int calcrc(char *ptr, int count) //求 CRC 的 calcrc 函数， ptr 是指向字符数组的指针
{ //count 是待求 CRC 校验码的字节数
    int i;
    unsigned int crc; //要返回的 CRC,16 位的
    unsigned char crc1, crc2, crc3; //指向数组中连续的三个字符（byte） ,8 位的
    ptr[count] = 0x00; //计算 CRC 串的末尾添加两个字节的 0x00
    ptr[count + 1] = 0x00;
    crc1 = *ptr++;
    crc2 = *ptr++;
    while (--count >= 0)
    {
        crc3 = *ptr++; //在 while 中补充下一个字符（8 个 bit）第 19 页
        for (i = 0; i < 8; ++i)
        {
            if (crc1 & 0x80) //判断 crc1 高位是否为 1
            {
                crc1 = crc1 << 1; //移出高位
                if (crc2 & 0x80) //判断 crc2 高位是否为 1
                {
                    crc1 = crc1 | 0x01; //crc1 低位由 0 变 1
                }
                crc2 = crc2 << 1; //crc2 移出高位
                if (crc3 & 0x80) //判断 crc3 高位是否为 1
                {
                    crc2 = crc2 | 0x01; //crc2 低位由 0 变 1
                }
                crc3 = crc3 << 1; //crc3 移出高位
                crc1 = crc1 ^ 0x10; //前 8bit 与 0x10 异或
                crc2 = crc2 ^ 0x21; //后 8bit 与 0x21 异或
            }
            else //如果 crc1 高位不为 1，只移位不做异或
            {
                crc1 = crc1 << 1;
                if (crc2 & 0x80)
                {
                    crc1 = crc1 | 0x01;
                }
                crc2 = crc2 << 1;
                if (crc3 & 0x80)
                {
                    crc2 = crc2 | 0x01;
                }
                crc3 = crc3 << 1;
            }
        } //for
    } //while
    crc = (crc1 << 8) + crc2; //返回的 16 位的 crc 校验码
    return (crc);
}

/*** BeginHeader get_hex2str*/
void get_hex2str(char *buf, int len);
/*** EndHeader */
void get_hex2str(char *buf, int len)
{
    int i;
    int j;
    unsigned char str[50];
    unsigned char str1[50];
    int rlen;
    memset(str, 0x00, sizeof(str));
    for (i = 0,j = 0; i < len; i++)
    {
        str[j++] = ((buf[i] & 0xf0) >> 4) + 0x30;
        str[j++] = ((buf[i] & 0x0f)) + 0x30;
    }
    rlen = j;
    for (i = 0; i < j; i++)
    {
        if (str[i] > 0x39) str[i] += 0x07;
    }

    memset(str1, 0x00, sizeof(str1));
    for (i = 0,j = 0; i < rlen; i++)
    {
        str1[j++] = ((str[i] & 0xf0) >> 4) + 0x30;
        str1[j++] = ((str[i] & 0x0f)) + 0x30;
    }
//	com_tlen = rlen;
    memset(com_tbuf, 0x00, sizeof(com_tbuf));
    sprintf(com_tbuf, "02%s03", str1);
    com_tlen = strlen(com_tbuf);
    printf("com_tbuf2:%s\r\n", com_tbuf);

}

//设备返回在线值 C 01 03 00 06 00 02 65 CB
//设备返回：01 03 04 28 F6 3F FC 48 A3
//28 F6 3F FC ：为4个字节的浮点数（当前测量值）, 1.97
//安格瑞
/*** BeginHeader rd_aigerui*/
int rd_aigerui(char port, char num, int code1, int code2);
/*** EndHeader */
int rd_aigerui(char port, char num, int code1, int code2)
{
    static int status;
    auto union uf f;
    auto char len;
    auto int crc16;
    auto char i;
    auto char a1, a2;
    costate
    {
        status = 0;

        memset(com_tbuf, 0x00, sizeof(com_tbuf));
        com_tbuf[0] = 0x00; //功能代码
        com_tbuf[1] = num;  //污染因子个数
        len = 2;
        if (num == 1)
        {
            com_tbuf[len++] = (code1 & 0xff00) >> 8;
            com_tbuf[len++] = (code1 & 0x00ff);
        }
        else if (num == 2)
        {
            com_tbuf[len++] = (code1 & 0xff00) >> 8;
            com_tbuf[len++] = (code1 & 0x00ff);
            com_tbuf[len++] = (code2 & 0xff00) >> 8;
            com_tbuf[len++] = (code2 & 0x00ff);
        }
        crc16 = calcrc(com_tbuf, len);

        com_tbuf[len++] = crc16 >> 8;
        com_tbuf[len++] = (char)crc16;

        get_hex2str(com_tbuf, len);

        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 60) && (com_rbuf[1] == 0x32) && (com_rbuf[com_rlen - 1] == 0x33))
        {
            a1 = strhexTohex(get_hex(com_rbuf[18], com_rbuf[19]));
            a2 = strhexTohex(get_hex(com_rbuf[20], com_rbuf[21]));
            f.ch[1] = ((a1 << 4) | a2);
            a1 = strhexTohex(get_hex(com_rbuf[22], com_rbuf[23]));
            a2 = strhexTohex(get_hex(com_rbuf[24], com_rbuf[25]));
            f.ch[0] = ((a1 << 4) | a2);
            com_f[0] = f.i[0];

            a1 = strhexTohex(get_hex(com_rbuf[34], com_rbuf[35]));
            a2 = strhexTohex(get_hex(com_rbuf[36], com_rbuf[37]));
            f.ch[3] = ((a1 << 4) | a2);
            a1 = strhexTohex(get_hex(com_rbuf[38], com_rbuf[39]));
            a2 = strhexTohex(get_hex(com_rbuf[40], com_rbuf[41]));
            f.ch[2] = ((a1 << 4) | a2);
            a1 = strhexTohex(get_hex(com_rbuf[42], com_rbuf[43]));
            a2 = strhexTohex(get_hex(com_rbuf[44], com_rbuf[45]));
            f.ch[1] = ((a1 << 4) | a2);
            a1 = strhexTohex(get_hex(com_rbuf[46], com_rbuf[47]));
            a2 = strhexTohex(get_hex(com_rbuf[48], com_rbuf[49]));
            f.ch[0] = ((a1 << 4) | a2);

            com_f[1] = f.l;
            status = 1;
        }
        else
        {
            com_f[0] = 0.0;
            com_f[1] = 0.0;
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}

//设备返回在线值 C 01 03 00 06 00 02 65 CB
//设备返回：01 03 04 28 F6 3F FC 48 A3
//28 F6 3F FC ：为4个字节的浮点数（当前测量值）, 1.97

/*** BeginHeader rd_dianchuang_2017*/
int rd_dianchuang_2017(char port, char addr);
/*** EndHeader */
int rd_dianchuang_2017(char port, char addr)
{
    static int status;
    auto union uf f;
    costate
    {
        status = 0;
        com_sec = 0L;
        com_tbuf[0] = addr;
        com_tbuf[1] = 3;
        com_tbuf[2] = 0;
        com_tbuf[3] = 6;
        com_tbuf[4] = 0;
        com_tbuf[5] = 2;
        com_tbuf[6] = 0x65;
        com_tbuf[7] = 0xCB;
        com_tlen = 8;
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (com_rlen >= 1 * 2 + 5 && com_rbuf[0] == addr)
        {
            f.ch[1] = com_rbuf[3];
            f.ch[0] = com_rbuf[4];
            f.ch[3] = com_rbuf[5];
            f.ch[2] = com_rbuf[6];
            com_f[0] = f.f;
            status = 1;
        }
        else
        {
            com_f[0] = 0.0;
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}



/*** BeginHeader rd_SULN_200*/
int rd_SULN_200(char port, char addr);
/*** EndHeader */
int rd_SULN_200(char port, char addr)
{
    static int status;
    auto union uf f;
    auto char *point;
    costate
    {
        status = 0;
        com_sec = 0L;
        com_tbuf[0] = '!';
        com_tbuf[1] = '0';
        com_tbuf[2] = addr + 0x30;
        com_tlen = 3;
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (com_rlen >= 5 && com_rbuf[0] == '#')
        {
            point = strchr(com_rbuf, ' ');
            com_f[0] = atoi(point + 1);
            point = strchr(com_rbuf, '#');
            com_f[1] = atoi(point + 1);
            status = 1;
        }
        else
        {
            com_f[0] = 0.0;
            status = 2;
        }
        com_sec = read_rtc();
        com_sec = read_rtc();
    }
    return status;
}



/*** BeginHeader YinShaJiuHuan*/
int YinShaJiuHuan(char port, char devAddr);
/*** EndHeader */
int YinShaJiuHuan(char port, char devAddr)
{
    static int status;
    auto union uf f;
    costate
    {
        status = 0;
        com_sec = 0L;
        pack_modbus_cmd(devAddr, 0x04, 0x8654, 0x0001);
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (com_rlen >= 1 * 2 + 5 && com_rbuf[0] == devAddr)
        {
            com_f[0] = (com_rbuf[3] * 256 + com_rbuf[4]) / 100.0;
            status = 1;
        }
        else
        {
            com_f[0] = 0.0;
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}

/*** BeginHeader rd_010203_DryVaule*/
int rd_010203_DryVaule(char port);
/*** EndHeader */
int rd_010203_DryVaule(char port)
{
    auto char ch;
    float f0, f1, f2, f3;
    if (getSampleChannel("S01", &ch, 1, &f0) == 1)
    {
        if (getSampleChannel("01", &ch, 1, &f1) == 1)
        {
            com_f[0] = f1 / (1 - (f0 / 100.0));;
        }
        if (getSampleChannel("02", &ch, 1, &f2) == 1)
        {
            com_f[1] = f2 / (1 - (f0 / 100.0));
        }
        if (getSampleChannel("03", &ch, 1, &f3) == 1)
        {
            com_f[2] = f3 / (1 - (f0 / 100.0));
        }
    }
    else
    {
        com_f[0] = 0.0;
        com_f[1] = 0.0;
        com_f[2] = 0.0;
    }
    com_sec = read_rtc();
    return 1;
}

/*** BeginHeader rd_flux_L_mag*/
int rd_flux_L_mag(char port, char addr);
/*** EndHeader */
int rd_flux_L_mag(char port, char addr)
{
    static int status;
    union  uf AI;

    costate
    {
        status = 0;
        pack_modbus_cmd(addr, 0x04, 0x1010, 0x02);
        com_write(port);
        waitfor(DelayMs(2000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 8) && (com_rbuf[0] == addr) && (com_rbuf[1] == 0x04))
        {
            AI.ch[3] = com_rbuf[3];
            AI.ch[2] = com_rbuf[4];
            AI.ch[1] = com_rbuf[5];
            AI.ch[0] = com_rbuf[6];
            com_f[0] = AI.f;           //瞬时流量

            pack_modbus_cmd(addr, 0x04, 0x1018, 0x04);
            com_write(port);
            waitfor(DelayMs(1000));
            memset(com_rbuf, 0x00, sizeof(com_rbuf));
            com_read(port);
            if ((com_rlen >= 10) && (com_rbuf[0] == addr) && (com_rbuf[1] == 0x04))
            {
                AI.ch[3] = com_rbuf[7];
                AI.ch[2] = com_rbuf[8];
                AI.ch[1] = com_rbuf[9];
                AI.ch[0] = com_rbuf[10];
                com_f[1] = AI.f;            //累计流量小数部分

                AI.ch[3] = com_rbuf[3];
                AI.ch[2] = com_rbuf[4];
                AI.ch[1] = com_rbuf[5];
                AI.ch[0] = com_rbuf[6];
                com_f[1] += AI.l;           //累计流量整数部分

                status = 1;
            }
        }
        if (status == 0)
        {
            status = 2;
            com_f[0] = 0.0;
            com_f[1] = 0.0;
        }
        com_sec = read_rtc();
    }
    return status;
}

/*** BeginHeader rd_flx_PH */
int  rd_flx_PH(char port);
/*** EndHeader */
int  rd_flx_PH(char port)
{
    static int status;
    auto float f;
    costate
    {
        status = 0;
        waitfor(DelayMs(2000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 6) && (com_rbuf[0] == 0x0a) && (com_rbuf[5] == 0x0d))
        {
            f = strhexTohex(com_rbuf[1]) * 1000;
            f += strhexTohex(com_rbuf[2]) * 100;
            f += strhexTohex(com_rbuf[3]) * 10;
            f += strhexTohex(com_rbuf[4]) * 1;
            f = f / 100.0;
            com_f[0] = f;
            status = 1;
        }
        else
        {
            com_f[0] = 0.0;
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}

/*** BeginHeader rd_flx_mag511 */
int rd_flx_mag511(char port, char addr);
/*** EndHeader */
int rd_flx_mag511(char port, char addr)
{
    static int status;
    auto float f;
    costate
    {
        status = 0;
        pack_modbus_cmd(addr, 0x04, 10, 4);
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 4 * 2 + 5) && (com_rbuf[0] == addr) && (com_rbuf[1] == 0x04))
        {
            f = com_rbuf[3] * 256 + com_rbuf[4];
            com_f[0] = f / 100.0;
            f = com_rbuf[6] * 256 * 256 * 256 + com_rbuf[7] * 256 * 256 + com_rbuf[8] * 256 + com_rbuf[9];
            com_f[1] = f;
            status = 1;
        }
        else
        {
            com_f[0] = 0.0;
            com_f[1] = 0.0;
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}

/*** BeginHeader rd_device_IGS100M */
int rd_device_IGS100M(char port, char addr, Rate rat);
/*** EndHeader */
int rd_device_IGS100M(char port, char addr, Rate rat)
{
    static int status;
    auto char i;
    auto struct tm comTime;
    auto CHARTOINTTY vaule;
    costate
    {
        status = 0;
        sprintf(com_tbuf, " %02d#RDD0048100484**\n", addr);
        com_tbuf[0] = '%';
        com_tlen = strlen(com_tbuf);
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);   //%01$RD4932122205137E006C\n
        if ((com_rlen >= 26) && (strncmp(&com_rbuf[3], "$RD", 3) == 0)) //是有效数据
        {
            comTime.tm_year = HexCharToDec(com_rbuf[16]) * 10 + HexCharToDec(com_rbuf[17]) + 100;
            comTime.tm_mon = HexCharToDec(com_rbuf[14]) * 10 + HexCharToDec(com_rbuf[15]);
            comTime.tm_mday = HexCharToDec(com_rbuf[12]) * 10 + HexCharToDec(com_rbuf[13]);
            comTime.tm_hour = HexCharToDec(com_rbuf[10]) * 10 + HexCharToDec(com_rbuf[11]);
            comTime.tm_min = HexCharToDec(com_rbuf[8]) * 10 + HexCharToDec(com_rbuf[9]);
            comTime.tm_sec = HexCharToDec(com_rbuf[6]) * 10 + HexCharToDec(com_rbuf[7]);
            com_sec = mktime(&comTime);         //时间

            memset(com_tbuf, 0x00, sizeof(com_tbuf));
            vaule.c[1] = HexCharToDec(com_rbuf[20]) * 0x10 + HexCharToDec(com_rbuf[21]);
            vaule.c[0] = HexCharToDec(com_rbuf[18]) * 0x10 + HexCharToDec(com_rbuf[19]);

            com_f[0] = vaule.i;
            switch (rat)
            {
            case RATE_10:
                com_f[0] *= 10;
                break;
            case RATE_100:
                com_f[0] *= 100;
                break;
            case RATE_1000:
                com_f[0] *= 1000;
                break;
            case RATE_10000:
                com_f[0] *= 10000;
                break;
            case RATE_0_10:
                com_f[0] /= 10;
                break;
            case RATE_0_100:
                com_f[0] /= 100;
                break;
            case RATE_0_1000:
                com_f[0] /= 1000;
                break;
            case RATE_0_10000:
                com_f[0] /= 10000;
                break;
            }
            status = 1;
        }
        else
        {
            com_f[0] = 0;
            com_sec = read_rtc();      //时间
            status = 2;
        }
    }
    return status;
}


/*** BeginHeader rd_get_SO2 */
int rd_get_SO2(void);
/*** EndHeader */
int rd_get_SO2(void)
{
    auto char ch;
    static float f1;
    static int status;
    status = 0;
    if (getSampleChannel("S04", &ch, 1, &f1) == 1)
    {
        com_f[0] = extendData[0] * 0.86 * sqrt(2 * f1 / 1.205);
        //速度场系数*皮托管系数* 开根号(2*烟气动压/烟气密度)
        status = 1;
    }
    else
    {
        com_f[0] = 0.0;
        status = 2;
    }
    com_sec = read_rtc();

    return status;
}


/*** BeginHeader set_flag_show*/
void set_flag_show(char flag);
/*** EndHeader */
void set_flag_show(char flag)
{
    auto char c;
    if (flag != 0)
    {
        for (c = 0; c < ALLADCHANNELS; c++)
        {
            if ((Savech[c].polIndex >= 0) && (Savech[c].polIndex < BOCON_NO_OF_POL))
            {
                if (flag == 0x4D)  //设备维护
                {
                    Savech[c].flag = 'M';
                }
                else if (flag == 0x43) //设备校准
                {
                    Savech[c].flag = 'C';
                }
            }
        }
    }
}


/*** BeginHeader modbus_get_B01_get_flag*/
int modbus_get_B01_get_flag(char port);
/*** EndHeader */
int modbus_get_B01_get_flag(char port)
{
    static int status;
    static char flag;

    auto unsigned int crc;
    auto char crc1, crc2;
    auto CHARTOINTTY regAddr; //读寄存器开始地址
    auto CHARTOINTTY regCount; //读寄存器数量
    auto char i, k, ch, c;
    auto float f;
    costate
    {
        flag  = 0;
        status  = 0;

        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (com_rlen >= 8 && com_rbuf[0] == modbusConfig[port].devAddr)
        {
            memset(com_tbuf, 0x00, sizeof(com_tbuf));
            regAddr.c[1] = com_rbuf[2];
            regAddr.c[0] = com_rbuf[3];
            regCount.c[1] = com_rbuf[4];
            regCount.c[0] = com_rbuf[5];
#define _________CMD0x03___________
            if (com_rbuf[1] == 0x03)
            {
                com_tbuf[0] = modbusConfig[port].devAddr;
                com_tbuf[1] = com_rbuf[1];
                com_tbuf[2] = regCount.i * 2;
                k = 3;
                for (i = 0; i < regCount.i / 2; i++)
                {
                    if (getSampleChannel("B01", &ch, 1, &f) == 1)
                    {
                        k = setRegFloatValue(port, f, k);
                    }
                    else
                    {
                        k = setRegFloatValue(port, 0.0, k);
                    }
                }
                crc = msrCRC(com_tbuf, k);
                com_tbuf[k++] = (char)(crc >> 8);
                com_tbuf[k++] = (char)(crc & 0xff);
                com_tlen = k;
                com_write(port);
            }
#define _________CMD0x06___________
            else if (com_rbuf[1] == 0x06)
            {
                k = 0;
                com_tbuf[k++] = modbusConfig[port].devAddr;
                com_tbuf[k++] = com_rbuf[1];
                com_tbuf[k++] = com_rbuf[2];
                com_tbuf[k++] = com_rbuf[3];
                com_tbuf[k++] = com_rbuf[4];
                com_tbuf[k++] = com_rbuf[5];
                crc = msrCRC(com_tbuf, k);
                com_tbuf[k++] = (char)(crc >> 8);
                com_tbuf[k++] = (char)(crc & 0xff);
                com_tlen = k;
                com_write(port);
                flag = com_rbuf[5];
            }
            status  = 1;
            set_flag_show(flag);
        }
        else
        {
            status  = 1;
            set_flag_show(flag);
        }
    }
    return status;
}


/*** BeginHeader plc_ctrl_flag_show*/
void plc_ctrl_flag_show(char port);
/*** EndHeader */
void plc_ctrl_flag_show(char port)
{
    static char openComFlag;
    costate
    {
        com_open(port, ai_param[port + 8].baudrate);
        com_databits(port, PARAM_8BIT);
        com_parity(port, ai_param[port + 8].parity);
        msDelay(20);
        while (1)
        {
            if (Savech[port + 8].polIndex >= BOCON_NO_OF_POL && ai_param[port + 8].model == 20000)
            {
                waitfor(modbus_get_B01_get_flag(port));
            }
            else
            {
                waitfor(DelayMs(100));
            }
        }
    }
}



//	    set_flag_show(flag);
//	}
//	status = 1;
//    }
//    return status;
//}


/*** BeginHeader PLC_modbus*/
int PLC_modbus(char port);
/*** EndHeader */
int PLC_modbus(char port)
{
    static int status;

    auto unsigned int crc;
    auto char crc1, crc2;
    auto CHARTOINTTY regAddr; //读寄存器开始地址
    auto CHARTOINTTY regCount; //读寄存器数量
    auto char i, k;
    auto union uf data;

    costate
    {
        com_open(port, ai_param[port+8].baudrate); //用指定的波特率打开串口
        com_databits(port, PARAM_8BIT);           //8个数据位，PARAM_7BIT
        com_parity(port, ai_param[port + 8].parity); //校验位，0,1,2,3
        msDelay(20);
        while (1)
        {
            com_read(port);
            if ((com_rlen >= 8) && (com_rbuf[0] == modbusConfig[port].devAddr))
            {
                crc = msrCRC(com_rbuf, 6);
                crc1 = (char)(crc >> 8);    //高位
                crc2 = (char)(crc & 0xff);  //低位
                if (com_rbuf[6] == crc1 && com_rbuf[7] == crc2)
                {
                    shegnyang_flag = 0;
                    if (com_rbuf[1] == 0x03)     //读
                    {
                        regAddr.c[1] = com_rbuf[2];  //地址
                        regAddr.c[0] = com_rbuf[3];
                        regCount.c[1] = com_rbuf[4]; //数量
                        regCount.c[0] = com_rbuf[5];

                        com_tbuf[0] = modbusConfig[port].devAddr;
                        com_tbuf[1] = 0x03;
                        com_tbuf[2] = 0x00;

                        if ((regAddr.i == 0) && (regCount.i == 2)) //读取模拟数据
                        {
                            k = 3;
                            for (i = 0; i < ALLADCHANNELS; i++)
                            {
                                if (Savech[i].polIndex == 0)
                                {
                                    k = setRegFloatValue(port, Savech[i].val, k);
                                    break;
                                }
                            }
//					k = setRegFloatValue(port, Savech[0].val, k);
                            com_tbuf[2] += 4;
                            crc = msrCRC(com_tbuf, k);
                            com_tbuf[k++] = (char)(crc >> 8);    //高位
                            com_tbuf[k++] = (char)(crc & 0xff);  //低位
                            com_tlen = k;          //发送数据长度
                            com_write(port);
                        }
                    }
                    else if (com_rbuf[1] == 0x06)    //写一个寄存器
                    {
                        regAddr.c[1] = com_rbuf[2];  //地址
                        regAddr.c[0] = com_rbuf[3];
                        if (regAddr.i == 2) //写入标志位
                        {
                            shegnyang_flag = com_rbuf[5];
                            //com_rbuf[5] = 0x4D	falg=M,设备维护
                            //com_rbuf[5] = 0x43	flag=C,设备维护

                            com_tbuf[0] = modbusConfig[port].devAddr;      //地址
                            com_tbuf[1] = com_rbuf[1];    //功能码
                            com_tbuf[2] = com_rbuf[2];    //起始地址
                            com_tbuf[3] = com_rbuf[3];
                            com_tbuf[4] = com_rbuf[4];    //寄存器数量
                            com_tbuf[5] = com_rbuf[5];
                            k = 6;
                            crc = msrCRC(com_tbuf, k);
                            com_tbuf[k++] = (char)(crc >> 8);    //高位
                            com_tbuf[k++] = (char)(crc & 0xff);  //低位
                            com_tlen = k;        //发送数据长度
                            com_write(port);
                        }
                        else shegnyang_flag = 0;
                    }
                }
            }
            else shegnyang_flag = 0;
            waitfor(DelayMs(1000));
        }
    }
}


/*** BeginHeader shengtai_PLCDevice*/
void shengtai_PLCDevice(void);
/*** EndHeader */
void shengtai_PLCDevice(void)
{
    auto char c;
    costate
    {
        while (1)
        {
            for (c = 8; c < 16; c++)
            {
                if (Savech[c].polIndex >= BOCON_NO_OF_POL && ai_param[c].model == 20001)
                {
                    PLC_modbus(c - 8);
                }
            }
            waitfor(DelayMs(1000));
        }
    }
}

/*** BeginHeader shengtai_SetFlag*/
void shengtai_SetFlag(void);
/*** EndHeader */
void shengtai_SetFlag(void)
{
    auto char c;
    if (shegnyang_flag != 0)
    {
        for (c = 0; c < ALLADCHANNELS; c++)
        {
            if ((Savech[c].polIndex >= 0) && (Savech[c].polIndex < BOCON_NO_OF_POL))
            {
                if (shegnyang_flag == 0x4D)  //设备维护
                    Savech[c].flag = 'M';
                else if (shegnyang_flag == 0x43) //设备校准
                    Savech[c].flag = 'C';
            }
        }
    }
}

//SJFC-200 粉尘仪通信协议
/*** BeginHeader rd_SJFC200*/
int rd_SJFC200(char port, char devAddr);
/*** EndHeader */
int rd_SJFC200(char port, char devAddr)
{
    static int status;
    auto union uf f;
    costate
    {
        status = 0;
        com_sec = 0L;
        pack_modbus_cmd(devAddr, 0x04, 0x8654, 0x0001);
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (com_rlen >= 1 * 2 + 5 && com_rbuf[0] == devAddr)
        {
            com_f[0] = (com_rbuf[3] * 256 + com_rbuf[4]) / 100.0;
            status = 1;
        }
        else
        {
            com_f[0] = 0.0;
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}

/*** BeginHeader rd_PLC_modbus*/
int rd_PLC_modbus(char port);
/*** EndHeader */
int rd_PLC_modbus(char port)
{
    static int status;
    union  uf AI;
    auto char i;

    costate
    {
        status = 0;
        pack_modbus_cmd(0x01, 0x03, 0, 26);
        com_write(port);
        waitfor(DelayMs(2000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 5 + 13 * 2) && (com_rbuf[0] == 0x01) && (com_rbuf[1] == 0x03))
        {
            for (i = 6; i < 13; i++)
            {
                AI.ch[1] = com_rbuf[3 + i * 4];
                AI.ch[0] = com_rbuf[4 + i * 4];
                AI.ch[3] = com_rbuf[5 + i * 4];
                AI.ch[2] = com_rbuf[6 + i * 4];
                com_f[i - 6] = AI.f;
            }
            status = 1;
        }
        if (status == 0)
        {
            status = 2;
            for (i = 6; i < 13; i++)
            {
                com_f[i - 6] = 0;
            }
        }
        com_sec = read_rtc();
    }
    return status;
}


/*** BeginHeader com_output_polcode_data_task*/
void com_output_polcode_data_task(char port);
/*** EndHeader */
void com_output_polcode_data_task(char port)
{
    auto char ch;
    auto union uf f;
    auto CHARTOINTTY tmp;
    auto char index;
    auto char i;
    costate
    {
        com_open(port, ai_param[port + 8].baudrate); //用指定的波特率打开串口
        com_databits(port, PARAM_8BIT);           //8个数据位，PARAM_7BIT
        com_parity(port, ai_param[port + 8].parity); //校验位，0,1,2,3
        msDelay(20);
        while (1)
        {

            index = 0;
            com_tbuf[index++] = 0x5a;
            com_tbuf[index++] = 0xa5;
            com_tbuf[index++] = 0x15;
            com_tbuf[index++] = 0x82;
            com_tbuf[index++] = 0x00;
            com_tbuf[index++] = 0x28;
            //TSP
            tmp.i = 0;
            if (getSampleChannel("901", &ch, 1, &f.f) == 1)
            {
                tmp.i = (unsigned)(f.f * 10);
            }
            com_tbuf[index++] = tmp.c[1];
            com_tbuf[index++] = tmp.c[0];
            //PM2.5
            tmp.i = 0;
            if (getSampleChannel("902", &ch, 1, &f.f) == 1)
            {
                tmp.i = (unsigned)(f.f * 10);
            }
            com_tbuf[index++] = tmp.c[1];
            com_tbuf[index++] = tmp.c[0];
            //PM10
            tmp.i = 0;
            if (getSampleChannel("903", &ch, 1, &f.f) == 1)
            {
                tmp.i = (unsigned)(f.f * 10);
            }
            com_tbuf[index++] = tmp.c[1];
            com_tbuf[index++] = tmp.c[0];
            //风速,风向,温度,湿度,气压,噪声
            for (i = 0; i < 6; i++)
            {
                com_tbuf[index++] = 0;
                com_tbuf[index++] = 0;
            }
            com_tbuf[index++] = 0x16;
            com_tlen = index;
            com_write(port);
            waitfor(DelayMs(1000));
        }
    }
}

//寄存器40105内存储的数据为当前气体读数的有效数字,最高位为符号位
/*** BeginHeader rd_LEAD_20*/
int rd_LEAD_20(char port, char addr);
/*** EndHeader */
int rd_LEAD_20(char port, char addr)
{
    static int status;
    auto CHARTOINTTY data;
    auto CHARTOINTTY point;
    costate
    {
        status = 0;
        pack_modbus_cmd(addr, 0x03, 103, 2);
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 5 + 2 * 2) && (com_rbuf[0] == addr) && (com_rbuf[1] == 0x03))
        {
            if (com_rbuf[3] & 0x80)
            {
                data.c[1] = com_rbuf[3];
                data.c[0] = com_rbuf[4];
                com_f[0] = 0.0 - ((float)(data.i) - 0X8000);
            }
            else
            {
                data.c[1] = com_rbuf[3];
                data.c[0] = com_rbuf[4];
                com_f[0] = (float)(data.i);
            }
            status = 1;
        }
        else
        {
            com_f[0] = 0.0;
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}


/*** BeginHeader rd_LiaoNingDeHui_9998*/
int rd_LiaoNingDeHui_9998(char port);
/*** EndHeader */
int rd_LiaoNingDeHui_9998(char port)
{
    static int status;
    auto union uf data;
    auto char index;
    auto unsigned int crc;
    costate
    {
        status = 0;
        index = 0;
        com_tbuf[index++] = 0x0a;
        com_tbuf[index++] = 0x03;
        com_tbuf[index++] = 0x00;
        com_tbuf[index++] = 0x67;
        com_tbuf[index++] = 0x00;
        crc = msrCRC(com_tbuf, index);
        com_tbuf[index++] = (char)(crc >> 8);
        com_tbuf[index++] = (char)(crc & 0xff);
        com_tlen = index;
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x0a))
        {
            data.ch[3] = com_rbuf[3];
            data.ch[2] = com_rbuf[4];
            data.ch[1] = com_rbuf[5];
            data.ch[0] = com_rbuf[6];
            com_f[0] = data.l;
            status = 1;
        }
        else
        {
            com_f[0] = 0.0;
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}

/*** BeginHeader rd_flux_ShenZhenGeYunHongBang*/
int rd_flux_ShenZhenGeYunHongBang(char port);
/*** EndHeader */
int rd_flux_ShenZhenGeYunHongBang(char port)
{
    static int status;
    union  uf f;
    auto char i;
    costate
    {
        status = 0;
        waitfor(DelayMs(2000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 12) && (com_rbuf[0] == 0x40) && (com_rbuf[com_rlen - 1] == 0x26))
        {
            f.ch[3] = com_rbuf[2];
            f.ch[2] = com_rbuf[3];
            f.ch[1] = com_rbuf[4];
            f.ch[0] = com_rbuf[5];
            com_f[0] = f.f;
            f.ch[3] = com_rbuf[6];
            f.ch[2] = com_rbuf[7];
            f.ch[1] = com_rbuf[8];
            f.ch[0] = com_rbuf[9];
            com_f[1] = f.f;
            status = 1;
        }
        else
        {
            com_f[0] = 0.0;
            com_f[1] = 0.0;
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}

/*** BeginHeader rd_DCSfloat3210 */
float rd_DCSfloat3210(char buf[], char len);
/*** EndHeader */
float rd_DCSfloat3210(char buf[], char len)
{
    auto union uf f; //uf这在K36的驱动库里已定义

    f.ch[3] = buf[7 + len * 4];
    f.ch[2] = buf[8 + len * 4];
    f.ch[1] = buf[9 + len * 4];
    f.ch[0] = buf[10 + len * 4];
    return f.f;
}

/*** BeginHeader rd_cems_DCS */
int rd_cems_DCS(char port);
/*** EndHeader */
int rd_cems_DCS(char port)
{
    static int status;
    auto union uf f; //uf这在K36的驱动库里已定义
    auto unsigned int i;
    static int len;
    auto char buf[1024];
    auto char *point;
    auto char c;
    costate
    {
        status = 0;
        waitfor(DelaySec(1));
        memset(buf, 0x00, sizeof(buf));
        len = 0;
        while (1)
        {
            memset(com_rbuf, 0x00, sizeof(com_rbuf));
            com_read(port);
            if (com_rlen > 0)
            {
                if ((len + com_rlen) >= 1024) break;
                memcpy(&buf[len], com_rbuf, com_rlen);
                len += com_rlen;
            }
            else break;
        }
        if (len > 0)
        {
            for (i = 0; i < len; i++)
            {
                if (buf[i] == 0x01)
                {
                    if (buf[i + 1] == 0x10)
                    {
                        point = &buf[i];    //找到帧头
                        break;
                    }
                }
            }
            com_open(2, ai_param[2 + 8].baudrate); //用指定的波特率打开串口
            com_databits(2, PARAM_8BIT);         //8个数据位，PARAM_7BIT
            com_parity(2, ai_param[2 + 8].parity); //校验位，0,1,2,3

            memcpy(com_tbuf, buf, len);
            com_tlen = len;
            com_write(2);     //串口3打印数据
        }
        if ((len > 0) && ((len - i) >= 9 + 24 * 4))
        {
            com_f[0] = rd_DCSfloat3210(point, 0);       //12个炉膛温度
            com_f[1] = rd_DCSfloat3210(point, 1);
            com_f[2] = rd_DCSfloat3210(point, 2);
            com_f[3] = rd_DCSfloat3210(point, 3);
            com_f[4] = rd_DCSfloat3210(point, 4);
            com_f[5] = rd_DCSfloat3210(point, 5);
            com_f[6] = rd_DCSfloat3210(point, 6);
            com_f[7] = rd_DCSfloat3210(point, 7);
            com_f[8] = rd_DCSfloat3210(point, 8);
            com_f[9] = rd_DCSfloat3210(point, 9);
            com_f[10] = rd_DCSfloat3210(point, 10);
            com_f[11] = rd_DCSfloat3210(point, 11);

            status = 1;
        }
        else
        {
            status = 2;
            for (i = 0; i < 12; i++) com_f[i] = 0.0;
        }
        com_sec = read_rtc();
    }
    return status;
}

/*** BeginHeader get_vocs_send_data*/
void get_vocs_send_data(char flag);
/*** EndHeader */
void get_vocs_send_data(char flag)
{
    auto char index;
    index = 0;
    com_tbuf[index++] = 0x01;
    com_tbuf[index++] = 0x10;
    com_tbuf[index++] = 0x01;
    com_tbuf[index++] = 0x70;
    com_tbuf[index++] = 0x01;
    com_tbuf[index++] = 0xf0;
    com_tbuf[index++] = 0x05;
    com_tbuf[index++] = 0x02;
    com_tbuf[index++] = 0x2f;
    com_tbuf[index++] = 0x10;
    com_tbuf[index++] = 0x01;
    if (flag == 0) //温度
    {
        com_tbuf[index++] = 0x64;
        com_tbuf[index++] = 0x00;
        com_tbuf[index++] = 0x03;
        com_tbuf[index++] = 0x71;
        com_tbuf[index++] = 0x4b;
        com_tbuf[index++] = 0x04;
    }
    else if (flag == 1) //压强
    {
        com_tbuf[index++] = 0x2c;
        com_tbuf[index++] = 0x01;
        com_tbuf[index++] = 0x03;
        com_tbuf[index++] = 0x1d;
        com_tbuf[index++] = 0x92;
        com_tbuf[index++] = 0x04;
    }
    else if (flag == 2) //湿度
    {
        com_tbuf[index++] = 0xc8;
        com_tbuf[index++] = 0x00;
        com_tbuf[index++] = 0x03;
        com_tbuf[index++] = 0x05;
        com_tbuf[index++] = 0xe1;
        com_tbuf[index++] = 0x04;
    }
    else if (flag == 3) //风速
    {
        com_tbuf[index++] = 0xc8;
        com_tbuf[index++] = 0x00;
        com_tbuf[index++] = 0x03;
        com_tbuf[index++] = 0xfc;
        com_tbuf[index++] = 0xbd;
        com_tbuf[index++] = 0x04;
    }
    else if (flag == 4) //风向
    {
        com_tbuf[index++] = 0xf4;
        com_tbuf[index++] = 0x01;
        com_tbuf[index++] = 0x03;
        com_tbuf[index++] = 0xd0;
        com_tbuf[index++] = 0xdb;
        com_tbuf[index++] = 0x04;
    }
    com_tlen = index;
}


/*** BeginHeader rd_JuGuang_VOCS*/
int rd_JuGuang_VOCS(char port);
/*** EndHeader */
int rd_JuGuang_VOCS(char port)
{
    static int status;
    union  uf f;
    static char i;
    costate
    {
        status = 0;
        i = 5;
        while (i)
        {
            i--;
            get_vocs_send_data(i);
            com_write(port);
            waitfor(DelayMs(1000));
            memset(com_rbuf, 0x00, sizeof(com_rbuf));
            com_read(port);
            if ((com_rlen >= 25) && (com_rbuf[0] == 0x01) && (com_rbuf[com_rlen - 1] == 0x04))
            {
                f.ch[0] = com_rbuf[17];
                f.ch[1] = com_rbuf[18];
                f.ch[2] = com_rbuf[19];
                f.ch[3] = com_rbuf[20];
                com_f[i] = f.f;
                status = 1;
            }
            else
            {
                com_f[i] = 0.0;
            }
        }
        com_sec = read_rtc();
        if (status == 0)
        {
            status = 2;
        }
    }
    return status;
}
//GC3000_115
//7d 7b 02 66 时间(19byte) 个数(1byte) 数据(个数*4) CRC 7d 7d
//7d 7b 02 66 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 3F C0 00 00 FF FF 7d 7d

//GC3000_210
//7d 7b 02 66 时间(19byte) 标志(1byte) 预留(1byte) 个数(1byte) 数据(个数*4) CRC 7d 7d
//7d 7b 02 66 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 3F C0 00 00 FF FF 7d 7d
/*** BeginHeader rd_GC3000*/
int rd_GC3000(char port, char flag);
/*** EndHeader */
int rd_GC3000(char port, char flag)
{
    static int status;
    union  uf f;
    auto char i;
    static char tmp;
    costate
    {
        status = 0;
        waitfor(DelaySec(33));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 30) && (com_rbuf[0] == 0x7d) && (com_rbuf[com_rlen - 1] == 0x7d))
        {
            if (flag == 1)
            {
                tmp = com_rbuf[23];
                for (i = 0; i < tmp; i++)
                {
                    f.ch[3] = com_rbuf[24 + i * 4];
                    f.ch[2] = com_rbuf[25 + i * 4];
                    f.ch[1] = com_rbuf[26 + i * 4];
                    f.ch[0] = com_rbuf[27 + i * 4];
                    com_f[i] = f.f;
                }
            }
            else
            {
                tmp = com_rbuf[25];
                for (i = 0; i < tmp; i++)
                {
                    f.ch[3] = com_rbuf[26 + i * 4];
                    f.ch[2] = com_rbuf[27 + i * 4];
                    f.ch[1] = com_rbuf[28 + i * 4];
                    f.ch[0] = com_rbuf[29 + i * 4];
                    com_f[i] = f.f;
                }
            }


            status = 1;
        }
        else
        {
            for (i = 0; i < tmp; i++)
            {
                com_f[i] = 0.0;
            }
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}


/*** BeginHeader rd_modbus_wendu_jianceyi*/
int rd_modbus_wendu_jianceyi(char port);
/*** EndHeader */
int rd_modbus_wendu_jianceyi(char port)
{
    static int status;
    static int deviceStatus;
    static char tmp;
    auto union  uf f;
    auto CHARTOINTTY int16;
    static float old_com_f[21];
    costate
    {
        status = 0;
        tmp = 0;
        while (tmp < modbusConfig[port].devAddr)
        {
            tmp++;
            pack_modbus_cmd(tmp, 0x03, 0x1001, 0x0001);
            com_write(port);
            waitfor(DelayMs(1000));
            memset(com_rbuf, 0x00, sizeof(com_rbuf));
            com_read(port);
            if ((com_rlen >= 2 * 1 + 5) && (com_rbuf[0] == tmp) && (com_rbuf[1] == 0x03))
            {
                int16.c[1] = com_rbuf[3];
                int16.c[0] = com_rbuf[4];
                com_f[tmp - 1] = int16.i / 10.0;
                old_com_f[tmp - 1] = com_f[tmp - 1];
                deviceStatus = 0;
            }
            else
            {
                if (++deviceStatus < 500)
                {
                    com_f[tmp - 1] = old_com_f[tmp - 1];
                }
                else
                {
                    com_f[tmp - 1] = 0.0;
                    old_com_f[tmp - 1] = 0.0;
                    deviceStatus = 500;
                }
            }
        }
        status = 1;
    }
    return status;
}

/*** BeginHeader TCP_8014 */
void TCP_8014(char no);
/*** EndHeader */
void TCP_8014(char no)
{
    auto int i;

    memset(deal_buf, 0x00, sizeof(deal_buf));
    xmem2root(deal_buf, tcp_rbuf[no], tcp_rlen[no]);

#ifdef DEBUG_PRINTF
    printf("R_%d: ", tcp_rlen[no]);
    for (i = 0; i < tcp_rlen[no]; i++)
    {
        printf("%02x ", deal_buf[i]);
    }
    printf(" \n");
#endif

    if (tcp_rlen[no] > 0)
    {
        strcpy(tcp_8014_buf, deal_buf);
    }

}

/*** BeginHeader rd_flux_ShangJinTaiJin*/
int rd_flux_ShangJinTaiJin(char port, char addr);
/*** EndHeader */
int rd_flux_ShangJinTaiJin(char port, char addr)
{
    static int status;
    auto union uf data;
    costate
    {
        status = 0;
        pack_modbus_cmd(addr, 0x03, 0x12, 2);
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 5 + 2 * 2) && (com_rbuf[0] == addr) && (com_rbuf[1] == 0x03))
        {
            data.ch[0] = com_rbuf[3];
            data.ch[1] = com_rbuf[4];
            data.ch[2] = com_rbuf[5];
            data.ch[3] = com_rbuf[6];
            com_f[0] = data.f;
            pack_modbus_cmd(addr, 0x03, 0x14, 2);
            com_write(port);
            waitfor(DelayMs(1000));
            memset(com_rbuf, 0x00, sizeof(com_rbuf));
            com_read(port);
            if ((com_rlen >= 5 + 2 * 2) && (com_rbuf[0] == addr) && (com_rbuf[1] == 0x03))
            {
                data.ch[0] = com_rbuf[3];
                data.ch[1] = com_rbuf[4];
                data.ch[2] = com_rbuf[5];
                data.ch[3] = com_rbuf[6];
                com_f[1] = data.l;
            }
            else
            {
                com_f[1] = 0.0;
            }
            status = 1;
        }
        else
        {
            com_f[0] = 0.0;
            com_f[1] = 0.0;
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}

/*** BeginHeader rd_flux_ChaoShengBoMingQu*/
int rd_flux_ChaoShengBoMingQu(char port, char addr);
/*** EndHeader */
int rd_flux_ChaoShengBoMingQu(char port, char addr)
{
    static int status;
    auto union uf data;
    costate
    {
        status = 0;
        pack_modbus_cmd(addr, 0x03, 0x00, 0x11);
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 5 + 0x11 * 2) && (com_rbuf[0] == addr) && (com_rbuf[1] == 0x03))
        {
            data.ch[3] = com_rbuf[5];
            data.ch[2] = com_rbuf[6];
            data.ch[1] = com_rbuf[7];
            data.ch[0] = com_rbuf[8];
            com_f[0] = data.l / 10.0;

            data.ch[3] = com_rbuf[9];
            data.ch[2] = com_rbuf[10];
            data.ch[1] = com_rbuf[11];
            data.ch[0] = com_rbuf[12];
            com_f[1] = data.l / 1.0;
            status = 1;
        }
        else
        {
            com_f[0] = 0.0;
            com_f[1] = 0.0;
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}
//东文流量计 新协议 原联进高程序
/*** BeginHeader rd_flux_dongwen */
int rd_flux_dongwen(char port);
/*** EndHeader */
/*******************************************************************************
发送命令 ：39
接收数据：00 00 30 38 6D 32 30 64 31 30 3A 31 33 27 20 51 3D 34 2E 35 34 37 4C 2F
53 20 4D 3D 30 30 30 34 32 39 30 33 20 00 00 00 00 00 00 30 37 39 42 0D
数值为：  08m20d10:13' Q=4.547L/S M=00042903       079B
*******************************************************************************/
int rd_flux_dongwen(char port)
{
    static int status;
    auto  char *temptr;
    auto unsigned long total;

    costate
    {
        status = 0;            //初始化通讯状态标志位
        com_tbuf[0] = 0x39;    //将需要发送的数据放入缓冲区
                               //com_tbuf[1] = 0x03;
                               //com_tbuf[2] = 0x90;
        com_tlen = 1;          //发送数据长度
        com_write(port);       //调用发送函数,将数据发送出去
        waitfor(DelayMs(1000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));  //清空接收缓冲区
        com_read(port);                            //调用接收函数,将数据放接收缓冲区中
        if (com_rlen >= 46)                         //接收数据的长度
        {

            temptr = strchr(&com_rbuf[10], 'Q');
            if (temptr != NULL)
            {
                temptr = strchr(temptr, '=');
                temptr++;
                com_f[0] = atof(temptr);      //瞬时流量
                /*
                #ifdef FLUX_UNIT_M3
                com_f[0] = com_f[0] * 3.6;
                #endif */
            }
            else
            {
                com_f[0] = 0.0;
                status++;
            }

            temptr = strchr(&com_rbuf[10], 'M');
            if (temptr != NULL)
            {
                temptr = strchr(temptr, '=');
                temptr++;
                total = atol(temptr);         //累计流量
                com_f[1] = total;
//            totalFlux = total;

#ifdef DEBUG_PRINTF
                printf("sumFlux=%f \n", com_f[1]);
#endif
            }
            else
            {
                com_f[1] = 0.0;
                status++;
            }
        }
        else
        {
            status = 2;
            com_f[0] = 0.0;
            com_f[1] = 0.0;
        }
        com_sec = read_rtc();               //采样时间
        if (status == 0)
        {
            status = 1;
        }
    }
    return status;
}

/*** BeginHeader rd_flux_dongwen_1 */
int rd_flux_dongwen_1(char port);
/*** EndHeader */
/*******************************************************************************
发送命令 ：39 03 90
接收数据：00 00 30 38 6D 32 30 64 31 30 3A 31 33 27 20 51 3D 34 2E 35 34 37 4C 2F
53 20 4D 3D 30 30 30 34 32 39 30 33 20 00 00 00 00 00 00 30 37 39 42 0D
数值为：  08m20d10:13' Q=4.547L/S M=00042903       079B
*******************************************************************************/
int rd_flux_dongwen_1(char port)
{
    static int status;
    auto  char *temptr;
    auto unsigned long total;

    costate
    {
        status = 0;            //初始化通讯状态标志位
        com_tbuf[0] = 0x39;    //将需要发送的数据放入缓冲区
        com_tbuf[1] = 0x03;
        com_tbuf[2] = 0x90;
        com_tlen = 3;          //发送数据长度
        com_write(port);       //调用发送函数,将数据发送出去
        waitfor(DelayMs(1000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));  //清空接收缓冲区
        com_read(port);                            //调用接收函数,将数据放接收缓冲区中
        if (com_rlen >= 46)                         //接收数据的长度
        {

            temptr = strchr(&com_rbuf[10], 'Q');
            if (temptr != NULL)
            {
                temptr = strchr(temptr, '=');
                temptr++;
                com_f[0] = atof(temptr);      //瞬时流量
                /*
                #ifdef FLUX_UNIT_M3
                com_f[0] = com_f[0] * 3.6;
                #endif */
            }
            else
            {
                com_f[0] = 0.0;
                status++;
            }

            temptr = strchr(&com_rbuf[10], 'M');
            if (temptr != NULL)
            {
                temptr = strchr(temptr, '=');
                temptr++;
                total = atol(temptr);         //累计流量
                com_f[1] = total;
//            totalFlux = total;

#ifdef DEBUG_PRINTF
                printf("sumFlux=%f \n", com_f[1]);
#endif
            }
            else
            {
                com_f[1] = 0.0;
                status++;
            }
        }
        else
        {
            status = 2;
            com_f[0] = 0.0;
            com_f[1] = 0.0;
        }
        com_sec = read_rtc();               //采样时间
        if (status == 0)
        {
            status = 1;
        }
        else
        {
            printf("2222222222222222222222\r\n");
        }
    }
    return status;
}

/*** BeginHeader rd_ljg_hach */
int rd_ljg_hach(char port, char flag);
/*** EndHeader */
int rd_ljg_hach(char port, char flag)
{
    static int status;
    auto struct tm comTime;
    auto union uf f; //uf这在K36的驱动库里已定义

    costate
    {
        status = 0;
        if (flag == 1) pack_modbus_cmd(0x20, 0x03, 0x9c40, 0x02);
        else pack_modbus_cmd(0x20, 0x03, 0x00, 0x02);
        com_write(port);
        waitfor(DelayMs(2000));

        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x20) && (com_rbuf[1] == 0x03))
        {
            f.ch[3] = com_rbuf[3];
            f.ch[2] = com_rbuf[4];
            f.ch[1] = com_rbuf[5];
            f.ch[0] = com_rbuf[6];
            com_f[0] = f.f;         //即时值

            status = 1;
        }
        else
        {
            status = 2;
            com_f[0] = 0.0;
        }

        com_sec = read_rtc();
    }
    return status;
}


/*** BeginHeader rd_WTW_andan*/
int rd_WTW_andan(char port, char addr);
/*** EndHeader */
int rd_WTW_andan(char port, char addr)
{
    static int status;
    auto union uf data;
    auto char *point;
    costate
    {
        status = 0;
        memset(com_tbuf, 0x00, sizeof(com_tbuf));
        com_tbuf[0] = 0xe1;
        com_tbuf[1] = 0x0f;
        strcpy(&com_tbuf[2], "%!?T1PBGMDATA");
        com_tbuf[15] = 0x06;
        com_tbuf[16] = 0x47;
        com_tlen = strlen(com_tbuf);
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 10) && (com_rbuf[0] == 0x0d) && (strstr(com_rbuf, "mg/l") != NULL))
        {
            point = strchr(com_rbuf, ':');
            if (point != NULL)
            {
                data.f = atof(point + 3);
                com_f[0] = data.f;
                status = 1;
            }
            else
            {
                com_f[0] = 0.0;
                status = 2;
            }
        }
        else
        {
            com_f[0] = 0.0;
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}



/*** BeginHeader rd_wanyi_shuizhi*/
int rd_wanyi_shuizhi(char port);
/*** EndHeader */
int rd_wanyi_shuizhi(char port)
{
    static int status;
    static char  tmp;
    costate
    {
        status = 0;
        tmp = 0;
        com_open(port, ai_param[port + 8].baudrate); //用指定的波特率打开串口
        com_databits(port, PARAM_7BIT);
        com_parity(port, PARAM_2STOP);
        msDelay(20);
        while (tmp < 3)
        {
            tmp++;
            modbusAsciiPacket(tmp, 0x04, 0xb1, 0x02);
            com_write(port);
            waitfor(DelayMs(1000));
            memset(com_rbuf, 0x00, sizeof(com_rbuf));
            com_read(port);
            if (isModbusAsciiPackErr(tmp, 0x04) == 0)
            {
                com_f[tmp - 1] = getModbusAsciiFloat1032(0xb1, 0xb1, com_rbuf);
            }
            else
            {
                com_f[tmp - 1] = 0.0;
            }
            com_sec = read_rtc();
        }
        status = 1;
    }
    return status;
}


/*** BeginHeader rd_device_htc_c*/
int rd_device_htc_c(char port);
/*** EndHeader */
int rd_device_htc_c(char port)
{
    static int status;
    auto union uf f;

    costate
    {
        status = 0;
        pack_modbus_cmd(0x01, 0x03, 0x0102, 0x02);
        com_write(port);
        waitfor(DelayMs(2000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x01) && (com_rbuf[1] == 0x03))
        {
            f.ch[1] = com_rbuf[3];
            f.ch[0] = com_rbuf[4];
            f.ch[3] = com_rbuf[5];
            f.ch[2] = com_rbuf[6];
            com_f[0] = f.f;
            status = 1;
        }
        else
        {
            com_f[0] = 0.0;
            status = 2;
        }

        com_sec = read_rtc();
    }
    return status;
}

//01 03 09 CB 00 02 B6 69
/*** BeginHeader rd_device_nanjinghongkai*/
int rd_device_nanjinghongkai(char port);
/*** EndHeader */
int rd_device_nanjinghongkai(char port)
{
    static int status;
    auto union uf f;

    costate
    {
        status = 0;
        pack_modbus_cmd(0x01, 0x03, 0x09cb, 0x02);
        com_write(port);
        waitfor(DelayMs(2000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (com_rbuf[0] == 0x01) && (com_rbuf[1] == 0x03))
        {
            f.ch[1] = com_rbuf[3];
            f.ch[0] = com_rbuf[4];
            f.ch[3] = com_rbuf[5];
            f.ch[2] = com_rbuf[6];
            com_f[0] = f.f;
            status = 1;
        }
        else
        {
            com_f[0] = 0.0;
            status = 2;
        }

        com_sec = read_rtc();
    }
    return status;
}


/*** BeginHeader rd_FRT_FWS*/
int rd_FRT_FWS(char port);
/*** EndHeader */
int rd_FRT_FWS(char port)
{
    static int status;
    auto union uf f;
    auto char *point;

    costate
    {
        status = 0;
        sprintf(com_tbuf, "%xR2\r\n", modbusConfig[port].devAddr);
        com_tlen = 5;
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 9) && (strstr(com_rbuf, "R2") != NULL))
        {
            point = strstr(com_rbuf, "Ta=");
            if (point != NULL)
            {
                com_f[0] = atof(point + 3);
            }
            else
            {
                com_f[0] = 0.0;
            }
            point = strstr(com_rbuf, "Ua=");
            if (point != NULL)
            {
                com_f[1] = atof(point + 3);
            }
            else
            {
                com_f[1] = 0.0;
            }
            point = strstr(com_rbuf, "Pa=");
            if (point != NULL)
            {
                com_f[2] = atof(point + 3);
            }
            else
            {
                com_f[2] = 0.0;
            }

            sprintf(com_tbuf, "%xR1\r\n", modbusConfig[port].devAddr);
            com_tlen = 5;
            com_write(port);
            waitfor(DelayMs(1000));
            memset(com_rbuf, 0x00, sizeof(com_rbuf));
            com_read(port);
            if ((com_rlen >= 9) && (strstr(com_rbuf, "R1") != NULL))
            {
                point = strstr(com_rbuf, "Sm=");
                if (point != NULL)
                {
                    com_f[3] = atof(point + 3);
                }
                else
                {
                    com_f[3] = 0.0;
                }

                point = strstr(com_rbuf, "Dm=");
                if (point != NULL)
                {
                    com_f[4] = atof(point + 3);
                }
                else
                {
                    com_f[4] = 0.0;
                }
            }
            else
            {
                com_f[3] = 0.0;
                com_f[4] = 0.0;
            }
            status = 1;
        }
        else
        {
            com_f[0] = 0.0;
            com_f[1] = 0.0;
            com_f[2] = 0.0;
            com_f[3] = 0.0;
            com_f[4] = 0.0;
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}
//惠州绿科 modbustcp
/*** BeginHeader modbusTcpRS232_task*/
void modbusTcpRS232_task(void);
/*** EndHeader */
/************************************************
1.串口输出modbusTCP协议，串口属性在相应界面配置。
2.串口收到数据：06 56 00 00 00 06 01 03 00 00 00 0A
************************************************/
void modbusTcpRS232_task(void)
{
#define MODBUS_TCP_RS232_COM	0
    auto int i;
    auto union uf data;
    //auto char buf[38];
    auto char f[32];
    auto char addr, count;
    costate
    {
        com_open(MODBUS_TCP_RS232_COM, ai_param[MODBUS_TCP_RS232_COM+8].baudrate); //用指定的波特率打开串口
        com_databits(MODBUS_TCP_RS232_COM, PARAM_8BIT);             //8个数据位，PARAM_7BIT
        com_parity(MODBUS_TCP_RS232_COM, ai_param[MODBUS_TCP_RS232_COM + 8].parity); //校验位，0,1,2,3
        msDelay(20);
        while (1)
        {
            com_read(MODBUS_TCP_RS232_COM);
#ifdef DEBUG_PRINTF
            printf("modbus tcp receive: ");
            for (i = 0; i < com_rlen; i++)
            {
                printf("%02x ", com_rbuf[i]);
            }
            printf("\r\n");
#endif
            if ((com_rlen >= 11) && (com_rbuf[6] == (char)devNo) && (com_rbuf[7] == 0x03) && (com_rbuf[11] <= 0x0a))
            {
                memset(com_tbuf, 0x00, sizeof(com_tbuf));
                memset(f, 0x00, sizeof(f));
                addr = com_rbuf[9];
                count = com_rbuf[11];
                com_tbuf[0] = com_rbuf[0]; com_tbuf[1] = com_rbuf[1];
                com_tbuf[2] = com_rbuf[2]; com_tbuf[3] = com_tbuf[3];
                com_tbuf[4] = com_rbuf[4];
                com_tbuf[5] = com_rbuf[11] * 2 + 0x03;
                com_tbuf[6] = (char)devNo;
                com_tbuf[7] = 0x03;
                com_tbuf[8] = com_rbuf[11] * 2;
                for (i = 0; i < ALLADCHANNELS; i++)
                {
                    if (Savech[i].polIndex == 1)
                    {
                        data.f = Savech[i].val;
                        f[0] = data.ch[3];
                        f[1] = data.ch[2];
                        f[2] = data.ch[1];
                        f[3] = data.ch[0];
                    }
                    else if (Savech[i].polIndex == 5)
                    {
                        data.f = Savech[i].val;
                        f[4] = data.ch[3];
                        f[5] = data.ch[2];
                        f[6] = data.ch[1];
                        f[7] = data.ch[0];
                    }
                    else if (Savech[i].polIndex == 29)
                    {
                        data.f = Savech[i].val;
                        f[8] = data.ch[3];
                        f[9] = data.ch[2];
                        f[10] = data.ch[1];
                        f[11] = data.ch[0];
                    }
                    else if (Savech[i].polIndex == 0)
                    {
                        data.f = Savech[i].val;
                        f[12] = data.ch[3];
                        f[13] = data.ch[2];
                        f[14] = data.ch[1];
                        f[15] = data.ch[0];

                        data.f = onemsg_wr.AI_Val[ch_flux].Total / 10000.0;

                        f[16] = data.ch[3];
                        f[17] = data.ch[2];
                        f[18] = data.ch[1];
                        f[19] = data.ch[0];
                    }
                    else if (Savech[i].polIndex == 31)
                    {
                        data.f = Savech[i].val;
                        f[20] = data.ch[3];
                        f[21] = data.ch[2];
                        f[22] = data.ch[1];
                        f[23] = data.ch[0];
                    }
                    else if (Savech[i].polIndex == 33)
                    {
                        data.f = Savech[i].val;
                        f[24] = data.ch[3];
                        f[25] = data.ch[2];
                        f[26] = data.ch[1];
                        f[27] = data.ch[0];
                    }
                }

                for (i = 0; i < count; i++, addr++)
                {
                    com_tbuf[9 + i * 2] = f[addr * 2];
                    com_tbuf[10 + i * 2] = f[addr * 2 + 1];
                }
                com_tlen = com_tbuf[5] + 0x06;
                com_write(MODBUS_TCP_RS232_COM);
            } //end of if
            waitfor(DelayMs(1000));
        } //end of while
    } //end of costate
}

/*** BeginHeader rd_JiangXiYiZheng_modbus*/
int rd_JiangXiYiZheng_modbus(char port, char addr, Rate rate);
/*** EndHeader */
int rd_JiangXiYiZheng_modbus(char port, char addr, Rate rate)
{
    static int status;
    auto union  uf f;
    auto CHARTOINTTY uint16;
    auto char i;

    costate
    {
        status = 0;
        pack_modbus_cmd(addr, 0x03, 0x0100, 0x0001);
        com_write(port);
        waitfor(DelayMs(2000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 5 + 2 * 1) && (com_rbuf[0] == addr) && (com_rbuf[1] == 0x03))
        {
            uint16.c[1] = com_rbuf[3];
            uint16.c[0] = com_rbuf[4];
            com_f[0] = uint16.i;

            pack_modbus_cmd(addr, 0x03, 0x0200, 0x0001);
            com_write(port);
            waitfor(DelayMs(2000));
            memset(com_rbuf, 0x00, sizeof(com_rbuf));
            com_read(port);
            if ((com_rlen >= 5 + 2 * 1) && (com_rbuf[0] == addr) && (com_rbuf[1] == 0x03))
            {
                uint16.c[1] = com_rbuf[3];
                uint16.c[0] = com_rbuf[4];
                com_f[1] = uint16.i;
            }
            else
            {
                com_f[1] = 0.0;
            }

            switch (rate)
            {
            case RATE_10:
                com_f[0] *= 10;
                com_f[1] *= 10;
                break;
            case RATE_100:
                com_f[0] *= 100;
                com_f[1] *= 100;
                break;
            case RATE_1000:
                com_f[0] *= 1000;
                com_f[1] *= 1000;
                break;
            case RATE_10000:
                com_f[0] *= 10000;
                com_f[1] *= 10000;
                break;
            case RATE_0_10:
                com_f[0] /= 10;
                com_f[1] /= 10;
                break;
            case RATE_0_100:
                com_f[0] /= 100;
                com_f[1] /= 100;
                break;
            case RATE_0_1000:
                com_f[0] /= 1000;
                com_f[1] /= 1000;
                break;
            case RATE_0_10000:
                com_f[0] /= 10000;
                com_f[1] /= 10000;
                break;
            default:
                break;
            }
            status = 1;
        }
        else
        {
            com_f[0] = 0.0;
            com_f[1] = 0.0;
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}

//无锡创晨科技重金属/COD/氨氮仪器
//01 04 00 02 00 09 91 CC
//01 04 12 0A D7 23 BC F6 28 FC 3F 07 DA 00 06 00 1D 00 0A 00 1E 1C 13
/*** BeginHeader rd_wuxi_cod_andan*/
int rd_wuxi_cod_andan(char port, char addr, Rate rate);
/*** EndHeader */
int rd_wuxi_cod_andan(char port, char addr, Rate rate)
{
    static int status;
    auto union  uf f;
    auto CHARTOINTTY uint16;
    auto char i;
    auto struct tm comTime;

    costate
    {
        status = 0;
        pack_modbus_cmd(addr, 0x04, 0x0002, 0x0009);
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 5 + 2 * 9) && (com_rbuf[0] == addr) && (com_rbuf[1] == 0x04))
        {
            f.ch[0] = com_rbuf[3 + 4 * 1];
            f.ch[1] = com_rbuf[4 + 4 * 1];
            f.ch[2] = com_rbuf[5 + 4 * 1];
            f.ch[3] = com_rbuf[6 + 4 * 1];
            com_f[0] = f.f;

            comTime.tm_year = com_rbuf[11] * 256 + com_rbuf[12] - 1900;
            comTime.tm_mon  = com_rbuf[13] * 256 + com_rbuf[14];
            comTime.tm_mday = com_rbuf[15] * 256 + com_rbuf[16];
            comTime.tm_hour = com_rbuf[17] * 256 + com_rbuf[18];
            comTime.tm_min  = com_rbuf[19] * 256 + com_rbuf[20];
            comTime.tm_sec  = 0;
            com_sec = mktime(&comTime);

            status = 1;
        }
        else
        {
            com_f[0] = 0.0;
            status = 2;
            com_sec = read_rtc();
        }
    }
    return status;
}
//发送: !01
//接收: #123456 11.11
/*** BeginHeader rd_flux_JiangXiBoYuan*/
int rd_flux_JiangXiBoYuan(char port, char addr);
/*** EndHeader */
int rd_flux_JiangXiBoYuan(char port, char addr)
{

    static int status;
    auto char *point;
    costate
    {
        status = 0;
        memset(com_tbuf, 0x00, sizeof(com_tbuf));
        sprintf(com_tbuf, "!%02d", addr);
        com_tlen = strlen(com_tbuf);
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 3) && (com_rbuf[0] == '#') && (strchr(com_rbuf, ' ') != NULL))
        {
            point = strchr(com_rbuf, ' ');
            com_f[0] = atof(point + 1);
            point = strchr(com_rbuf, '#');
            com_f[1] = atof(point + 1);
            status = 1;
        }
        else
        {
            com_f[0] = 0.0;
            com_f[1] = 0.0;
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}
//希思迪总铜分析仪
//#r\r\n
//02\08\10   07:58
//0025.067 0025.140 1234.526 1234.567
/*** BeginHeader rd_analyzer_xisidun*/
int rd_analyzer_xisidun(char port);
/*** EndHeader */
int rd_analyzer_xisidun(char port)
{
    static int status;
    auto char *point;
    auto char tmp;
    costate
    {
        status = 0;
        pack_string_cmd("#r\r\n");
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 10) && (strstr(com_rbuf, "\r\n") != NULL))
        {
            point = strstr(com_rbuf, "\r\n") + 2;
            com_f[0] = atof(point);
            for (tmp = 1; tmp < 10; tmp++)
            {
                point = strchr(point, ' ');
                if (point != NULL)
                {
                    point += 1;
                    com_f[tmp] = atof(point);
                }
                else
                {
                    break;
                }
            }
            status = 1;
        }
        else
        {
            for (tmp = 0; tmp < 11; tmp++)
            {
                com_f[tmp] = 0.0;
            }
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}

//485接4个仪表
/*** BeginHeader rd_485_more_instrument */
int rd_485_more_instrument(char port);
/*** EndHeader */
int rd_485_more_instrument(char port)
{
    static int status;
    auto union uf data;
    auto char *temptr;
    costate
    {
        status = 0;
        //流量计
        com_tbuf[0] = 0x11;
        com_tlen = 1;
        com_write(port);
        waitfor(DelaySec(2));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));  //清空接收缓冲区
        com_read(port);                            //调用接收函数,将数据放接收缓冲区中
        if (com_rlen >= 40)                         //接收数据的长度
        {
            temptr = strchr(&com_rbuf[10], 'Q');
            if (temptr != NULL)
            {
                temptr = strchr(temptr, '=');
                temptr++;
                com_f[0] = atof(temptr);      //瞬时流量
            }
            else
            {
                com_f[0] = 0.0;
            }

            temptr = strchr(&com_rbuf[10], 'M');
            if (temptr != NULL)
            {
                temptr = strchr(temptr, '=');
                temptr++;
                com_f[1] = atol(temptr);         //累计流量
            }
            else
            {
                com_f[1] = 0.0;
            }
        }
        else
        {
            com_f[0] = 0.0;
            com_f[1] = 0.0;
        }
        //氟离子
        pack_modbus_cmd(0x01, 0x03, 35, 2);
        com_write(port);
        waitfor(DelaySec(2));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (com_rbuf[0] == 0x01 && com_rbuf[1] == 0x03 && com_rlen > 8)
        {
            data.ch[3] = com_rbuf[3];
            data.ch[2] = com_rbuf[4];
            data.ch[1] = com_rbuf[5];
            data.ch[0] = com_rbuf[6];
            com_f[2] = data.f;
        }
        else
        {
            com_f[2] = 0.0;
        }
        //总磷总氮
        pack_modbus_cmd(0x02, 0x04, 8, 2);
        com_write(port);
        waitfor(DelaySec(2));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (com_rbuf[0] == 0x02 && com_rbuf[1] == 0x04 && com_rlen > 8)
        {
            data.ch[3] = com_rbuf[3];
            data.ch[2] = com_rbuf[4];
            data.ch[1] = com_rbuf[5];
            data.ch[0] = com_rbuf[6];
            com_f[3] = data.f;
        }
        else
        {
            com_f[3] = 0.0;
        }
        pack_modbus_cmd(0x02, 0x04, 28, 2);
        com_write(port);
        waitfor(DelaySec(2));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (com_rbuf[0] == 0x02 && com_rbuf[1] == 0x04  && com_rlen > 8)
        {
            data.ch[3] = com_rbuf[3];
            data.ch[2] = com_rbuf[4];
            data.ch[1] = com_rbuf[5];
            data.ch[0] = com_rbuf[6];
            com_f[4] = data.f;
        }
        else
        {
            com_f[4] = 0.0;
        }
        //COD
        pack_modbus_cmd(0x03, 0x04, 22, 2);
        com_write(port);
        waitfor(DelaySec(2));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (com_rbuf[0] == 0x03 && com_rbuf[1] == 0x04 && com_rlen > 8)
        {
            data.ch[3] = com_rbuf[3];
            data.ch[2] = com_rbuf[4];
            data.ch[1] = com_rbuf[5];
            data.ch[0] = com_rbuf[6];
            com_f[5] = data.f;
        }
        else
        {
            com_f[5] = 0.0;
        }
        status = 1;
        com_sec = read_rtc();
    }
    return status;
}

//环保铅粉排放监控系统上报通信协议
//#RT,1<CR><LF>
//从机应答
//设备不存在时：
//$RT,1,0<CR><LF>
//设备通信正常时：
//$RT,1,1,一号设备,0.125,1,0.06,4.6,0.496,25.8,正风压,234,负风压,124,三级压差,34<CR><LF>
//设备通信中断时：
//$RT,1,2,一号设备,0.125<CR><LF>

/*** BeginHeader rd_protocol_qianfen*/
int rd_protocol_qianfen(char port);
/*** EndHeader */
int rd_protocol_qianfen(char port)
{
    static int status;
    auto char *point;
    auto char tmp;
    costate
    {
        status = 0;
        pack_string_cmd("#RT,1\r\n");
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 5) && (strstr(com_rbuf, "$RT") != NULL))
        {
            point = strchr(com_rbuf, ',') + 1;
            point = strchr(point, ',') + 1;
            if (atoi(point) == 1) //通信正常
            {
                point = strchr(point, ',') + 1;
                point = strchr(point, ',') + 1; //排风筒截面积
                point = strchr(point, ',') + 1; //工作状态
                point = strchr(point, ',') + 1; //铅粉排放浓度
                com_f[0] = atof(point);
                point = strchr(point, ',') + 1; //风速
                com_f[2] = atof(point);
                point = strchr(point, ',') + 1; //铅粉排放流量
                com_f[1] = atof(point);
                point = strchr(point, ',') + 1; //排风温度
                com_f[3] = atof(point);
                point = strchr(point, ',') + 1; //差压 1 名称
                point = strchr(point, ',') + 1; //差压 1 当前值
                status = 1;
            }
            else
            {
                com_f[0] = 0.0;
                com_f[1] = 0.0;
                com_f[2] = 0.0;
                com_f[3] = 0.0;
                status = 2;
            }
        }
        else
        {
            com_f[0] = 0.0;
            com_f[1] = 0.0;
            com_f[2] = 0.0;
            com_f[3] = 0.0;
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}
//	成都鑫翼腾 武汉四方光电烟气系统
/*** BeginHeader rd_SFGD_yanqi*/
int rd_SFGD_yanqi(char port, unsigned delayTime);
/*** EndHeader */
int rd_SFGD_yanqi(char port, unsigned delayTime)
{
    static int status;
    auto char portPosition;
    auto char p;
    auto char *point;
    auto char *startoffset;
    auto int i;
    auto int len;

    costate
    {
        status = 0;

        waitfor(DelaySec(delayTime));
        memset(deal_buf, 0x00, sizeof(deal_buf));
        len = 0;

        len = com_readV2(port, deal_buf, sizeof(deal_buf), 200);
        if (len <= 0)
        {
            status = 2;
            goto RETURN_MARK;
        }
        point = strstr(deal_buf, "DataTime");   //数据头
        if (point == NULL)
        {
            status = 2;
            goto RETURN_MARK;
        }
        point = strstr(deal_buf, "So2=");    //二氧化硫实测值
        if (point != NULL) com_f[0] = atof(point + 4);
        else com_f[0] = 0;
        point = strstr(deal_buf, "NOx=");    //氮氧化物实测值
        if (point != NULL) com_f[1] = atof(point + 4);
        else com_f[1] = 0;
        point = strstr(deal_buf, "O2=");     //氧气实测值
        if (point != NULL) com_f[2] = atof(point + 3);
        else com_f[2] = 0;
        point = strstr(deal_buf, "Humi=");   //湿度实测值
        if (point != NULL) com_f[3] = atof(point + 5);
        else com_f[3] = 0;
        point = strstr(deal_buf, "Temp=");   //温度实测值
        if (point != NULL) com_f[4] = atof(point + 5);
        else com_f[4] = 0;
        point = strstr(deal_buf, "Speed=");  //流速实测值
        if (point != NULL) com_f[5] = atof(point + 6);
        else com_f[5] = 0;
        point = strstr(deal_buf, "Press=");  //压力实测值
        if (point != NULL) com_f[6] = atof(point + 6);
        else com_f[6] = 0;
        point = strstr(deal_buf, "Stive=");  //粉尘实测值
        if (point != NULL) com_f[7] = atof(point + 6);
        else com_f[7] = 0;
        point = strstr(deal_buf, "StiveConvert=");   //粉尘折算值
        if (point != NULL) com_f[8] = atof(point + 13);
        else com_f[8] = 0;
        point = strstr(deal_buf, "So2Convert="); //二氧化硫折算值
        if (point != NULL) com_f[9] = atof(point + 11);
        else com_f[9] = 0;
        point = strstr(deal_buf, "NOxConvert="); //氮氧化物折算值
        if (point != NULL) com_f[10] = atof(point + 11);
        else com_f[10] = 0;
        point = strstr(deal_buf, "FLOW=");   //干烟气流量
        if (point != NULL) com_f[11] = atof(point + 5);
        else com_f[11] = 0;

        status = 1;

    RETURN_MARK:
        com_sec = read_rtc();
    }
    return status;
}

//希思迪串口协议V1.2
/*
#D1<CR><LF>   (<CR><代表空格键,<LF>代表回车键,发送间隔3秒)
000 21/11/16---11:23
+0001.01 +0002.01 +0003.01 +0004.01
+0001.02 +0002.02 +0003.02 +0004.02
+0001.03 +0002.03 +0003.03 +0004.03
*/
/*** BeginHeader rd_protocol_xisidun_serial*/
int rd_protocol_xisidun_serial(char port, char flag);
/*** EndHeader */
int rd_protocol_xisidun_serial(char port, char flag)
{
    static int status;
    auto char *point;
    auto struct tm comTime;
    auto char tmp;
    costate
    {
        status = 0;
        pack_string_cmd("#D1 \r");
        com_write(port);
        waitfor(DelayMs(3000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if ((com_rlen >= 10) && (strstr(com_rbuf, "---") != NULL))
        {
            point = com_rbuf;
            if (atof(point) == 0)
            {
                point = strchr(point, ':');
                point += 4;
                for (tmp = 0; tmp < 4; tmp++)
                {
                    com_f[tmp] = atof(point);
                    point = strchr(point, ' ');
                    point += 1;
                }
                status = 1;
            }
            else
            {
                for (tmp = 0; tmp < 4; tmp++)
                {
                    com_f[tmp] = 0.0;
                }
                status = 2;
            }

            point = strchr(com_rbuf, ' ');
            point += 1;
            comTime.tm_mday = atoi(point);
            point = strchr(point, '/');
            point += 1;
            comTime.tm_mon  = atoi(point);
            point = strchr(point, '/');
            point += 1;
            comTime.tm_year = atoi(point) + 2000 - 1900;
            point = strstr(point, "---");
            point += 3;
            comTime.tm_hour = atoi(point);
            point = strchr(point, ':');
            point += 1;
            comTime.tm_min = atoi(point);
            comTime.tm_sec  = 0;
            com_sec = mktime(&comTime);
#if 0
            printf("%04d-%02d-%02d-%02d-%02d-00\r\n", comTime.tm_year,
                   comTime.tm_mon,
                   comTime.tm_mday,
                   comTime.tm_hour,
                   comTime.tm_min);
#endif
        }
        else
        {
            for (tmp = 0; tmp < 4; tmp++)
            {
                com_f[tmp] = 0.0;
            }
            status = 2;
            com_sec = read_rtc();
        }
    }
    return status;
}


/*** BeginHeader rd_TNP4200 */
int rd_TNP4200(char port, char addr);
/*** EndHeader */
int rd_TNP4200(char port, char addr)
{

    static int status;
    auto union uf data;
    costate
    {
        status = 0;
        pack_modbus_cmd(addr, 0x04, 8, 2);
        com_write(port);
        waitfor(DelaySec(1));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (com_rbuf[0] == addr && com_rbuf[1] == 0x04 && com_rlen > 8)
        {
            data.ch[3] = com_rbuf[3];
            data.ch[2] = com_rbuf[4];
            data.ch[1] = com_rbuf[5];
            data.ch[0] = com_rbuf[6];
            com_f[0] = data.f;

            pack_modbus_cmd(addr, 0x04, 28, 2);
            com_write(port);
            waitfor(DelaySec(1));
            memset(com_rbuf, 0x00, sizeof(com_rbuf));
            com_read(port);
            if (com_rbuf[0] == addr && com_rbuf[1] == 0x04  && com_rlen > 8)
            {
                data.ch[3] = com_rbuf[3];
                data.ch[2] = com_rbuf[4];
                data.ch[1] = com_rbuf[5];
                data.ch[0] = com_rbuf[6];
                com_f[1] = data.f;
            }
            else
            {
                com_f[1] = 0.0;
            }
            status = 1;
        }
        else
        {
            status = 2;
            com_f[0] = 0.0;
            com_f[1] = 0.0;
        }
        com_sec = read_rtc();
    }
    return status;
}

//广州新环，阳江分公司，原宁波东驰驱动，10202
/*** BeginHeader rd_flux_lmag*/
int rd_flux_lmag(char port);
/*** EndHeader */
int rd_flux_lmag(char port)
{
    static int status;
    auto union uf data;
    auto CHARTOINTTY data1;
    costate
    {
        status = 0;

        memset(com_tbuf, 0x00, sizeof(com_tbuf));
        pack_modbus_cmd(0x01, 0x04, 0x1010, 0x02);
        com_write(port);
        waitfor(DelaySec(1));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (com_rlen > 8 && com_rbuf[0] == 0x01 && com_rbuf[1] == 0x04)
        {
            data.ch[0] = com_rbuf[6];
            data.ch[1] = com_rbuf[5];
            data.ch[2] = com_rbuf[4];
            data.ch[3] = com_rbuf[3];
            com_f[0] = data.f;

            memset(com_tbuf, 0x00, sizeof(com_tbuf));
            pack_modbus_cmd(0x01, 0x04, 0x1020, 0x01);
            com_write(port);
            waitfor(DelaySec(1));
            memset(com_rbuf, 0x00, sizeof(com_rbuf));
            com_read(port);
            if (com_rlen > 6 && com_rbuf[0] == 0x01 && com_rbuf[1] == 0x04)
            {
                if (com_rbuf[4] == 0x05)
                {
                    com_f[0] = com_f[0] / 3.6;
                }
            }

            memset(com_tbuf, 0x00, sizeof(com_tbuf));
            pack_modbus_cmd(0x01, 0x04, 0x1018, 0x04);
            com_write(port);
            waitfor(DelaySec(1));
            memset(com_rbuf, 0x00, sizeof(com_rbuf));
            com_read(port);
            if (com_rlen > 6 && com_rbuf[0] == 0x01 && com_rbuf[1] == 0x04)
            {
                data.ch[0] = com_rbuf[10];
                data.ch[1] = com_rbuf[9];
                data.ch[2] = com_rbuf[8];
                data.ch[3] = com_rbuf[7];
                com_f[1] = data.f;

                data.ch[0] = com_rbuf[6];
                data.ch[1] = com_rbuf[5];
                data.ch[2] = com_rbuf[4];
                data.ch[3] = com_rbuf[3];
                com_f[1] += data.l;
            }
        }
        else
        {
            com_f[0] = 0.0;
            com_f[1] = 0.0;
        }

        memset(com_tbuf, 0x00, sizeof(com_tbuf));
        pack_modbus_cmd(0x02, 0x04, 0x1010, 0x02);
        com_write(port);
        waitfor(DelaySec(1));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (com_rlen > 8 && com_rbuf[0] == 0x02 && com_rbuf[1] == 0x04)
        {
            data.ch[0] = com_rbuf[6];
            data.ch[1] = com_rbuf[5];
            data.ch[2] = com_rbuf[4];
            data.ch[3] = com_rbuf[3];
            com_f[2] = data.f;

            memset(com_tbuf, 0x00, sizeof(com_tbuf));
            pack_modbus_cmd(0x02, 0x04, 0x1020, 0x01);
            com_write(port);
            waitfor(DelaySec(1));
            memset(com_rbuf, 0x00, sizeof(com_rbuf));
            com_read(port);
            if (com_rlen > 6 && com_rbuf[0] == 0x02 && com_rbuf[1] == 0x04)
            {
                if (com_rbuf[4] == 0x05)
                {
                    com_f[2] = com_f[2] / 3.6;
                }
            }

            memset(com_tbuf, 0x00, sizeof(com_tbuf));
            pack_modbus_cmd(0x02, 0x04, 0x1018, 0x02);
            com_write(port);
            waitfor(DelaySec(1));
            memset(com_rbuf, 0x00, sizeof(com_rbuf));
            com_read(port);
            if (com_rlen > 6 && com_rbuf[0] == 0x02 && com_rbuf[1] == 0x04)
            {
                data.ch[0] = com_rbuf[10];
                data.ch[1] = com_rbuf[9];
                data.ch[2] = com_rbuf[8];
                data.ch[3] = com_rbuf[7];
                com_f[3] = data.f;

                data.ch[0] = com_rbuf[6];
                data.ch[1] = com_rbuf[5];
                data.ch[2] = com_rbuf[4];
                data.ch[3] = com_rbuf[3];
                com_f[3] += data.l;
            }
        }
        else
        {
            com_f[2] = 0.0;
            com_f[3] = 0.0;
        }

        //40 30 31 52 44 31 37 0d
        com_tbuf[0] = 0x40;
        com_tbuf[1] = 0x30;
        com_tbuf[2] = 0x31;
        com_tbuf[3] = 0x52;
        com_tbuf[4] = 0x44;
        com_tbuf[5] = 0x31;
        com_tbuf[6] = 0x37;
        com_tbuf[7] = 0x0d;
        com_tlen = 8;
        com_write(port);

        waitfor(DelaySec(1));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);

        if (com_rlen >= 10 && com_rbuf[0] == 0x40 && com_rbuf[2] == 0x31)
        {
            data1.c[0] = strhexTohex(com_rbuf[5]);
            data1.c[0] <<= 4;
            data1.c[0] |= strhexTohex(com_rbuf[6]);
            data1.c[1] = strhexTohex(com_rbuf[7]);
            data1.c[1] <<= 4;
            data1.c[1] |= strhexTohex(com_rbuf[8]);
            com_f[4] = data1.i / 100.0;
        }
        else
        {
            com_f[4] = 0.0;
        }

        //40 30 31 52 44 31 37 0d
        com_tbuf[0] = 0x40;
        com_tbuf[1] = 0x30;
        com_tbuf[2] = 0x32;
        com_tbuf[3] = 0x52;
        com_tbuf[4] = 0x44;
        com_tbuf[5] = 0x31;
        com_tbuf[6] = 0x34;
        com_tbuf[7] = 0x0d;
        com_tlen = 8;
        com_write(port);

        waitfor(DelaySec(1));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);

        if (com_rlen >= 10 && com_rbuf[0] == 0x40 && com_rbuf[2] == 0x32)
        {
            data1.c[0] = strhexTohex(com_rbuf[5]);
            data1.c[0] <<= 4;
            data1.c[0] |= strhexTohex(com_rbuf[6]);
            data1.c[1] = strhexTohex(com_rbuf[7]);
            data1.c[1] <<= 4;
            data1.c[1] |= strhexTohex(com_rbuf[8]);
            com_f[5] = data1.i / 100.0;
        }
        else
        {
            com_f[5] = 0.0;
        }


        status = 1;
        com_sec = read_rtc();
    }
    return status;
}


/*** BeginHeader rd_cems_huashijie */
int rd_cems_huashijie(char port);
/*** EndHeader */
int rd_cems_huashijie(char port)
{

    static int status;
    auto union uf data;
    auto char i;
    costate
    {
        status = 0;
        pack_modbus_cmd(0x01, 0x03, 0, 24);
        com_write(port);
        waitfor(DelaySec(1));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (com_rbuf[0] == 0x01 && com_rbuf[1] == 0x03 && com_rlen > 8)
        {
            for (i = 0; i < 4; i++)
            {
                data.ch[3] = com_rbuf[3 + i * 4];
                data.ch[2] = com_rbuf[4 + i * 4];
                data.ch[1] = com_rbuf[5 + i * 4];
                data.ch[0] = com_rbuf[6 + i * 4];
                com_f[i] = data.f;
            }

            for (i = 0; i < 8; i++)     //后8个设置在模拟量
            {
                data.ch[3] = com_rbuf[3 + (i + 4) * 4];
                data.ch[2] = com_rbuf[4 + (i + 4) * 4];
                data.ch[1] = com_rbuf[5 + (i + 4) * 4];
                data.ch[0] = com_rbuf[6 + (i + 4) * 4];
                if ((Savech[i].polIndex >= 0) && (Savech[i].polIndex < BOCON_NO_OF_POL))
                {
                    Savech[i].time = SEC_TIMER;   //读入时间
                    Savech[i].val = data.f;
                    Savech[i].flag = 'N';
                }
                else
                {
                    Savech[i].time = 0L;          //没用的通道，时间置0
                    Savech[i].val = 0.0;          //没用的通道，数据置0
                    Savech[i].flag = 'D';         //标记为没有信号
                }
            }

            status = 1;
        }
        else
        {
            status = 2;
            com_f[0] = 0.0;
            com_f[1] = 0.0;
            com_f[2] = 0.0;
            com_f[3] = 0.0;
        }
        com_sec = read_rtc();
    }
    return status;
}
//西昌三峰，S06的值作为flag值
/*** BeginHeader disp_flag_S06*/
void disp_flag_S06(void);
/*** EndHeader */
void disp_flag_S06(void)
{
    auto char tmp,f;
	auto char ch;
    static char flag;
	auto float dat;
    costate
    {
	while (1)
	{
		if(getSampleChannel("S06", &ch, 1, &dat) == 1)
		{
			f = (char)dat;
		}
		else
			f = 0;
	    for (tmp = 0; tmp < ALLADCHANNELS; tmp++)
	    {
			if ((Savech[tmp].polIndex >= 0) && (Savech[tmp].polIndex < BOCON_NO_OF_POL))
			{
			    switch (f)
			    {
				    case 0:
					Savech[tmp].flag = 'B';
					break;
				    case 1:
					Savech[tmp].flag = 'N';
					break;
				    case 2:
					Savech[tmp].flag = 'F';
					break;
				    case 3:
					Savech[tmp].flag = 'M';
					break;
				    case 4:
					Savech[tmp].flag = 'S';
					break;
				    case 5:
					Savech[tmp].flag = 'D';
					break;
				    case 6:
					Savech[tmp].flag = 'C';
					break;
				    case 7:
					Savech[tmp].flag = 'T';
					break;
				    default:
					break;
			    }

			}
	    }
	    waitfor(DelayMs(100));
	}
    }
}


/*** BeginHeader getSample_kengsheng_v2*/
int getSample_kengsheng_v2(char port);
/*** EndHeader */
/*******************************************************************************
科盛 留样器
*******************************************************************************/
int getSample_kengsheng_v2(char port)
{
	static int status;
   auto int i;
   static char num;

   costate
   {
	  status = 0;
	  	  
	  if(num > 0x02)
		num = 0x01;
      //超标留样指令  AA 11 00 01 02 01 00 BB
      com_tlen = 0;
      com_tbuf[com_tlen++] = 0xAA;
      com_tbuf[com_tlen++] = 0x11;
      com_tbuf[com_tlen++] = 0x00;
      com_tbuf[com_tlen++] = 0x00+num;	//瓶号
      com_tbuf[com_tlen++] = 0x02;
      com_tbuf[com_tlen++] = 0x01;
      com_tbuf[com_tlen++] = 0x00;
      com_tbuf[com_tlen++] = 0xBB;
      com_write(port);

      waitfor(DelaySec(1));

      //成功收到指令，采样器返回：cc bb

      memset(com_rbuf, 0x00, sizeof(com_rbuf));
      com_read(port);

      //CC BB AA 39 32 BB
      if(com_rlen > 0)
      {
         #ifdef DEBUG_PRINTF
         for (i = 0; i < com_rlen; i++)
         {
          	printf("%02X ", com_rbuf[i]);
         }
         printf(" \n");
         #endif
      }
      else
      {
         #ifdef DEBUG_PRINTF
         printf("no receive data \n");
         #endif
      }
	  num++;

//      msDelay(100);
//      com_read(port);
//      com_close(port);   //完成命令发送，关闭串口
//      msDelay(10);       //延时50ms，等待串口底层驱动完全关闭
      status = 1;
   }

   return status;
}


/*** BeginHeader rd_flux_jiubo_add_jiubo */
int rd_flux_jiubo_add_jiubo(char port);
/*** EndHeader */
int rd_flux_jiubo_add_jiubo(char port)
{
    static int status;
    auto  char *point;
    costate
    {
        status = 0;
        com_tbuf[0] = 0x11;
        com_tlen = 1;
        com_write(port);
        waitfor(DelayMs(1000));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (com_rlen >= 40)
        {
            point = strchr(&com_rbuf[10], 'Q');
            if (point != NULL)
            {
                point = strchr(point, '=');
                point++;
                com_f[0] = atof(point) + flux;      //瞬时流量
            }
            else
            {
                com_f[0] = 0.0 + flux;
            }
            point = strchr(&com_rbuf[10], 'M');
            if (point != NULL)
            {
                point = strchr(point, '=');
                point++;
                com_f[1] = atol(point) + fluxSum;         //累计流量
            }
            else
            {
                com_f[1] = 0.0 + fluxSum;
            }
            status = 1;
        }
        else
        {
            com_f[0] = flux + 0.0;
            com_f[1] = fluxSum + 0.0;
            status = 2;
        }
        com_sec = read_rtc();
    }
    return status;
}


/*** BeginHeader get_flux_jiubo */
void get_flux_jiubo(char port);
/*** EndHeader */
void get_flux_jiubo(char port)
{
    auto  char *point;
    costate
    {
        com_open(port, ai_param[port + 8].baudrate); //用指定的波特率打开串口
        com_databits(port, PARAM_8BIT);           //8个数据位，PARAM_7BIT
        com_parity(port, ai_param[port + 8].parity); //校验位，0,1,2,3
        msDelay(20);
        flux = 0;
        fluxSum = 0;
        while (1)
        {
            com_tbuf[0] = 0x11;
            com_tlen = 1;
            com_write(port);
            waitfor(DelayMs(1000));
            memset(com_rbuf, 0x00, sizeof(com_rbuf));
            com_read(port);
            if (com_rlen >= 40)
            {
                point = strchr(&com_rbuf[10], 'Q');
                if (point != NULL)
                {
                    point = strchr(point, '=');
                    point++;
                    flux = atof(point);      //瞬时流量
                }
                else
                {
                    flux = 0.0;
                }
                point = strchr(&com_rbuf[10], 'M');
                if (point != NULL)
                {
                    point = strchr(point, '=');
                    point++;
                    fluxSum = atol(point);         //累计流量
                }
                else
                {
                    fluxSum = 0.0;
                }
            }
            else
            {
                flux = 0.0;
                fluxSum = 0.0;
            }
            waitfor(DelayMs(1000));
        }
    }
}


//南京弘礼，松下反控
/*** BeginHeader start_device_songxia */
void start_device_songxia(char port);
/*** EndHeader */
void start_device_songxia(char port)
{
    memset(com_tbuf, 0x00, sizeof(com_tbuf));
    strcpy(com_tbuf, "%01#WCSR06801**\r\n");
    com_tlen = strlen(com_tbuf);
    com_write(port);
    msDelay(100);
}

//松下反控协议
/*** BeginHeader rd_songxia*/
int rd_songxia(char port);
/*** EndHeader */
int rd_songxia(char port)
{
    static int status;
    auto union uf data;
	auto long dat;
    costate
    {
        status = 0;
		
		memset(com_tbuf, 0x00, sizeof(com_tbuf));
		strcpy(com_tbuf, "%01#RDD0152101525**\r\n");
		com_tlen = strlen(com_tbuf);
		com_write(port);
        waitfor(DelaySec(1));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
			//%01$RD0803271521260000040718\r\n
		if(com_rlen > 28 && com_rbuf[0] == '%')
		{
			dat = atol(&com_rbuf[18])/100;
		}
		com_f[0] = (float)dat/10.0;
        
        status = 1;
        com_sec = read_rtc();
    }
    return status;
}

//博思达流量计,南京弘礼用
/*** BeginHeader rd_flux_bosida*/
int rd_flux_bosida(char port,char comNo,char addr);
/*** EndHeader */
int rd_flux_bosida(char port,char comNo,char addr)
{
    static int status;
    auto union uf data;
	auto char i;
    costate
    {
        status = 0;

        memset(com_tbuf, 0x00, sizeof(com_tbuf));
        pack_modbus_cmd(addr, 0x03, 1962, 4);
        com_write(port);
        waitfor(DelaySec(1));
        memset(com_rbuf, 0x00, sizeof(com_rbuf));
        com_read(port);
        if (com_rlen > 8 && com_rbuf[0] == addr && com_rbuf[1] == 0x03)
        {
            data.ch[3] = com_rbuf[3];
            data.ch[2] = com_rbuf[4];
            data.ch[1] = com_rbuf[5];
            data.ch[0] = com_rbuf[6];
            com_f[0] = data.f;
            data.ch[3] = com_rbuf[3+1*4];
            data.ch[2] = com_rbuf[4+1*4];
            data.ch[1] = com_rbuf[5+1*4];
            data.ch[0] = com_rbuf[6+1*4];
            com_f[1] = data.l;
			    
			for(i=0;i<2;i++)
			{
			    switch (modbusConfig[comNo].ratedata)
			    {
				    case RATE_10:
					com_f[i] *= 10;
					break;
				    case RATE_100:
					com_f[i] *= 100;
					break;
				    case RATE_1000:
					com_f[i] *= 1000;
					break;
				    case RATE_10000:
					com_f[i] *= 10000;
					break;
				    case RATE_0_10:
					com_f[i] /= 10;
					break;
				    case RATE_0_100:
					com_f[i] /= 100;
					break;
				    case RATE_0_1000:
					com_f[i] /= 1000;
					break;
				    case RATE_0_10000:
					com_f[i] /= 10000;
					break;
			    }
			}
        }
        status = 1;
        com_sec = read_rtc();
    }
    return status;
}

//原广州世锦程序驱动，GB_160411
/*** BeginHeader GHmagPacket*/
void GHmagPacket(char port, char address, char function);
/*** EndHeader */
void GHmagPacket(char port, char address, char function)
{
	com_tbuf[0] = 0x2A;   //开始码
   	com_tbuf[1] = address;   //地址
   	com_tbuf[2] = function;   //功能码
   	com_tbuf[3] = 0x2E;   //结束
   	com_tlen = 4;
   	com_write(port);
}

/*** BeginHeader rd_flux_GHmag_v1*/
int rd_flux_GHmag_v1( char port );
/*** EndHeader */
int rd_flux_GHmag_v1( char port )
{
	static int status;
   	auto long d0, d1, d2, d3, d4;
   	auto union uf f;//uf这在K36的驱动库里已定义
   	auto float point;
   	float flux1,fluxSum1;

   	costate
   	{
    	status = 0;
      	GHmagPacket(port, 1, 0);
      	waitfor(DelayMs(2000));

      	memset(com_rbuf, 0x00, sizeof(com_rbuf));
      	com_read(port);
      	if( (com_rlen >= 10)&&(com_rbuf[1] == 0x00) )
      	{
         	d0 = (com_rbuf[2] >> 4) * 10 + (com_rbuf[2] & 0x0F);
         	d1 = (com_rbuf[3] >> 4) * 10 + (com_rbuf[3] & 0x0F);
         	d2 = (com_rbuf[4] >> 4) * 10 + (com_rbuf[4] & 0x0F);
         	flux1 = (float)(10000 * d2 + 100 * d1 + d0);
         	point = com_rbuf[5];
         	point -= 5;
         	flux1 = flux1 * pow10(point);
         	if(com_rbuf[6] == 2)
         	{
         		flux1 /= 3.6;
         	}
         	com_f[0] = flux1;
         	printf("flux1=%f\r\n", flux1);

         	GHmagPacket(port,1,4);
      		waitfor(DelayMs(2000));

         	memset(com_rbuf, 0x00, sizeof(com_rbuf));
      		com_read(port);
      		if( (com_rlen >= 10)&&(com_rbuf[9] == 0xAA) )
         	{
            	d0 = (com_rbuf[2] >> 4) * 10 + (com_rbuf[2] & 0x0F);
         		d1 = (com_rbuf[3] >> 4) * 10 + (com_rbuf[3] & 0x0F);
         		d2 = (com_rbuf[4] >> 4) * 10 + (com_rbuf[4] & 0x0F);
            	d3 = (com_rbuf[5] >> 4) * 10 + (com_rbuf[5] & 0x0F);
         		d4 = (com_rbuf[6] >> 4) * 10 + (com_rbuf[6] & 0x0F);
         		fluxSum1 = (float)(100000000 * d4 + 1000000 * d3 + 10000 * d2 + 100 * d1 + d0);
            	com_f[1] = fluxSum1;
            	printf("fluxSum1=%f\r\n", fluxSum1);
         	}
         	status = 1;
      	}
      	else
      	{
			status = 2;
         	com_f[0] = 0.0;
         	com_f[1] = 0.0;
      	}

      	com_sec = read_rtc();
   	}
   	return status;
}


//华时捷，计算流速
/*** BeginHeader rd_device_countS02*/
int rd_device_countS02(char port);
/*** EndHeader */
int rd_device_countS02(char port)
{
    auto union uf f;
	auto char ch;
	auto float f1,f2,f3;
	auto float dat1,dat2;
	//温度，压力，流速
	if((getSampleChannel("S03",&ch,1,&f2) == 1) &&
	   (getSampleChannel("S08",&ch,1,&f3) == 1) &&
	   (getSampleChannel("37",&ch,1,&f1) == 1))
	{
		dat1 = sqrt(105*(273.15+f2)/((f3+101.325)*423.15));
		dat2 = 40.014*dat1*sqrt(f1/1475.3);
			com_f[0] = dat2;
	}
    com_sec = read_rtc();
	return 1;
}

//广州碧源，雨量计
/*** BeginHeader rd_flux_biyuan*/
int rd_flux_biyuan( char port );
/*** EndHeader */
int rd_flux_biyuan( char port )
{
	static int status;
   	auto union uf f;//uf这在K36的驱动库里已定义

   	costate
   	{
    	status = 0;
		
		memset(com_tbuf,0x00,sizeof(com_tbuf));
		strcpy(com_tbuf,"M;\r");
		com_tlen = strlen(com_tbuf);
		com_write(port);
      	waitfor(DelayMs(2000));

      	memset(com_rbuf, 0x00, sizeof(com_rbuf));
      	com_read(port);
      	if( (com_rlen >= 10)&&(com_rbuf[com_rlen-1] == '\n') )
      	{
         	com_f[0] = atof(&com_rbuf[1]);
         	printf("flux1=%f\r\n", com_f[0]);
         	status = 1;
      	}
      	else
      	{
			status = 2;
         	com_f[0] = 0.0;
      	}

      	com_sec = read_rtc();
   	}
   	return status;
}


/*** BeginHeader */
#endif
/*** EndHeader */






